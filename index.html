<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ç„¡å°¾ç†Šè¨±é¡˜æ±  ğŸ¨ğŸ’–</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#ffcdd2">
    
    <!-- å¼•å…¥è¶…åœ“æ½¤å­—é«” -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-gradient: linear-gradient(180deg, #fff0f5 0%, #ffebee 100%);
            --text-main: #880e4f;
            --accent: #ff80ab;
            --accent-shadow: #f06292;
            --card-bg: #ffffff;
            --price-color: #ff9e80;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background: var(--bg-gradient);
            font-family: 'Varela Round', sans-serif; /* åœ“é«” */
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column;
            color: var(--text-main);
        }

        /* === é ‚éƒ¨ç„¡å°¾ç†Šå€ === */
        .mascot-area {
            width: 100%; height: 100px;
            display: flex; justify-content: center; align-items: flex-end;
            position: relative; z-index: 10;
            margin-top: 10px;
        }
        #koala-svg {
            width: 90px; height: 80px;
            filter: drop-shadow(0 5px 10px rgba(233,30,99,0.1));
            cursor: pointer;
            transition: transform 0.1s;
        }
        #koala-svg:active { transform: scale(0.9); }
        
        /* çœ¨çœ¼å‹•ç•« */
        .eye { animation: blink 4s infinite; transform-origin: center; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        /* è€³æœµå‹•å‹• */
        .ear { animation: wiggle 3s infinite ease-in-out; transform-origin: center bottom; }
        @keyframes wiggle { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(5deg); } }

        /* === åº•éƒ¨å°èˆªåˆ— (åƒæ£‰èŠ±ç³–) === */
        .nav-bar {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9); 
            padding: 8px 25px; border-radius: 50px;
            display: flex; gap: 30px; 
            box-shadow: 0 10px 30px rgba(255, 128, 171, 0.25);
            border: 4px solid #fff;
            z-index: 1000;
        }
        .nav-item {
            font-size: 1.5rem; color: #ffcdd2; cursor: pointer; transition: 0.3s;
            width: 55px; height: 55px; display: flex; justify-content: center; align-items: center;
            border-radius: 50%; background: #fff;
        }
        .nav-item.active { 
            background: var(--accent); color: white; 
            transform: translateY(-15px) scale(1.1); 
            box-shadow: 0 6px 0 var(--accent-shadow);
        }

        /* === é é¢å®¹å™¨ === */
        .page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s, transform 0.3s; opacity: 0; pointer-events: none;
        }
        .page.active { opacity: 1; pointer-events: all; transform: scale(1); }

        /* === éŠæˆ²é é¢ === */
        #game-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 0 20px 110px 20px;
            display: flex; flex-direction: column; justify-content: flex-end;
        }
        
        /* åˆ†æ•¸æ¿ */
        .game-header {
            display: flex; justify-content: space-between; align-items: flex-end;
            margin-bottom: 10px; padding: 0 10px;
        }
        .score-bubble {
            background: white; padding: 5px 15px; border-radius: 20px;
            border: 3px solid #fff0f5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
        }
        .score-label { font-size: 0.7rem; color: #ff80ab; font-weight: bold; letter-spacing: 1px; }
        .score-val { font-size: 1.4rem; font-weight: 900; font-family: 'Fredoka'; color: #880e4f; }

        /* æ£‹ç›¤ (åƒä¸€å¡Šé¤…ä¹¾) */
        #board-container {
            width: 100%; aspect-ratio: 1/1; 
            background: #fff;
            border-radius: 30px; padding: 15px; 
            box-shadow: 0 10px 0 #f8bbd0, 0 20px 30px rgba(0,0,0,0.1);
            border: 6px solid #ffebee;
            position: relative;
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 20px; display: block; }
        
        #spawn-area { width: 100%; height: 130px; display: flex; justify-content: space-around; align-items: center; }
        
        .shape-preview { width: 75px; height: 75px; transition: transform 0.1s; filter: drop-shadow(0 5px 0 rgba(0,0,0,0.1)); }
        .shape-preview.dragging { opacity: 0.9; z-index: 2000; position: fixed; transform: scale(1.2); pointer-events: none; }

        /* === å…Œæ›å•†åº—é é¢ === */
        #shop-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 80px 20px 120px 20px;
            display: flex; flex-direction: column; align-items: center;
            overflow-y: auto;
        }
        
        .wallet-card {
            background: linear-gradient(135deg, #ff80ab, #ff4081);
            color: white; width: 100%; padding: 25px; border-radius: 35px;
            box-shadow: 0 15px 30px rgba(255, 64, 129, 0.3); margin-bottom: 25px;
            display: flex; justify-content: space-between; align-items: center;
            border: 4px solid rgba(255,255,255,0.4);
            position: relative; overflow: hidden;
        }
        .wallet-card::before {
            content: 'â™¥'; position: absolute; font-size: 10rem; color: rgba(255,255,255,0.1);
            top: -20px; right: -20px; transform: rotate(20deg);
        }
        .coin-display { font-size: 2.5rem; font-weight: 900; font-family: 'Fredoka'; text-shadow: 0 3px 0 rgba(0,0,0,0.1); }
        
        .shop-list { width: 100%; display: flex; flex-direction: column; gap: 15px; }
        
        .coupon-item {
            background: white; border-radius: 25px; padding: 15px 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 5px 0 #fce4ec, 0 10px 20px rgba(0,0,0,0.05); 
            transition: 0.1s; border: 2px solid #fff;
        }
        .coupon-item:active { transform: translateY(5px); box-shadow: 0 0 0 #fce4ec; }
        
        .coupon-icon { font-size: 2.5rem; margin-right: 15px; width: 55px; text-align: center; }
        .coupon-name { font-weight: bold; font-size: 1.1rem; color: #555; margin-bottom: 5px; }
        .coupon-price { 
            color: white; background: #ffcc80; 
            display: inline-block; padding: 4px 12px; border-radius: 15px;
            font-weight: bold; font-size: 0.85rem; font-family: 'Fredoka';
        }
        
        .btn-redeem {
            background: var(--accent); color: white; border: none; padding: 10px 20px;
            border-radius: 25px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 var(--accent-shadow); transition: 0.1s;
        }
        .btn-redeem:active { transform: translateY(4px); box-shadow: none; }
        .btn-redeem:disabled { background: #eeeeee; box-shadow: none; color: #bbb; cursor: not-allowed; transform: none; }

        /* === éš±è—çš„å¾Œå°æŒ‰éˆ• === */
        #secret-btn {
            position: fixed; top: 10px; right: 10px; opacity: 0.05; font-size: 1.5rem;
            z-index: 3000; cursor: pointer;
        }

        /* === å½ˆçª— === */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9); z-index: 4000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            display: none; backdrop-filter: blur(5px);
        }
        .overlay-card {
            background: #fff0f5; padding: 30px; border-radius: 30px; width: 85%; max-width: 400px;
            text-align: center; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 10px 30px rgba(233,30,99,0.15); border: 5px solid white;
        }
        .log-list { list-style: none; text-align: left; margin-top: 15px; }
        .log-item { 
            border-bottom: 2px dashed #f8bbd0; padding: 12px 0; display: flex; justify-content: space-between;
            font-size: 0.9rem; color: #880e4f;
        }

        /* æµ®å‹•æ–‡å­— */
        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff4081; font-size: 2rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 3000;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-50px) scale(1.2); opacity:1; } 100% { transform:translateY(-80px) scale(1); opacity:0; } }
        
        /* æ„›å¿ƒå™´ç™¼å‹•ç•« */
        .pop-heart {
            position: absolute; font-size: 1.5rem; pointer-events: none;
            animation: popUp 0.8s forwards;
        }
        @keyframes popUp { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 50% { opacity: 1; } 100% { transform: translate(-50%, -100px) scale(1.5); opacity: 0; } }
    </style>
</head>
<body>

<!-- é ‚éƒ¨ç„¡å°¾ç†Š (é»æ“Šæœƒå™´æ„›å¿ƒ) -->
<div class="mascot-area">
    <div id="koala-trigger" onclick="koalaClick(event)">
        <svg id="koala-svg" viewBox="0 0 100 80">
            <!-- èº«é«” -->
            <ellipse cx="50" cy="80" rx="30" ry="20" fill="#cfd8dc"/>
            <!-- è€³æœµ -->
            <circle class="ear" cx="20" cy="25" r="12" fill="#cfd8dc"/>
            <circle class="ear" cx="80" cy="25" r="12" fill="#cfd8dc"/>
            <circle class="ear" cx="20" cy="25" r="7" fill="#ffcdd2"/>
            <circle class="ear" cx="80" cy="25" r="7" fill="#ffcdd2"/>
            <!-- é ­ -->
            <circle cx="50" cy="40" r="32" fill="#eceff1"/>
            <!-- çœ¼ç› -->
            <circle class="eye" cx="38" cy="38" r="4" fill="#455a64"/>
            <circle class="eye" cx="62" cy="38" r="4" fill="#455a64"/>
            <!-- é¼»å­ -->
            <ellipse cx="50" cy="45" rx="8" ry="6" fill="#455a64"/>
            <!-- è…®ç´… -->
            <circle cx="28" cy="48" r="5" fill="rgba(255,128,171,0.4)"/>
            <circle cx="72" cy="48" r="5" fill="rgba(255,128,171,0.4)"/>
        </svg>
    </div>
</div>

<!-- éš±è—å¾Œå°æŒ‰éˆ• -->
<div id="secret-btn" onclick="Admin.showLogs()">â¤ï¸</div>

<!-- å°èˆª -->
<div class="nav-bar">
    <div class="nav-item active" onclick="switchPage('game')">
        <i class="fas fa-gamepad"></i>
    </div>
    <div class="nav-item" onclick="switchPage('shop')">
        <i class="fas fa-gift"></i>
    </div>
</div>

<!-- 1. éŠæˆ²é é¢ -->
<div id="game-page" class="page active">
    <div id="game-wrapper">
        <div class="game-header">
            <div style="font-weight:900; color:#f06292; font-size:1.2rem;">
                <i class="fas fa-star" style="color:#ffd54f;"></i> è¨±é¡˜æ± 
            </div>
            <div class="score-bubble">
                <div class="score-label">LEAVES</div>
                <div class="score-val" id="game-coins">0</div>
            </div>
        </div>

        <div id="board-container">
            <canvas id="game-canvas" width="800" height="800"></canvas>
        </div>
        <div id="spawn-area"></div>
    </div>
</div>

<!-- 2. å…Œæ›å•†åº—é é¢ -->
<div id="shop-page" class="page">
    <div id="shop-wrapper">
        <div class="wallet-card">
            <div>
                <div style="font-size:0.9rem; opacity:0.9; font-weight:bold;">æˆ‘çš„è‘‰å­éŒ¢åŒ…</div>
                <div class="coin-display" id="total-coins">0</div>
            </div>
            <div style="font-size:3rem;">ğŸŒ¿</div>
        </div>

        <h3 style="margin-bottom:15px; color:var(--text-main); align-self:flex-start; font-weight:900;">
            ğŸ å…Œæ›å¦³çš„é¡˜æœ›
        </h3>
        <div class="shop-list" id="shop-container"></div>
    </div>
</div>

<!-- å¾Œå°å½ˆçª— -->
<div id="overlay">
    <div class="overlay-card">
        <h3 style="color:var(--text-main);">ğŸ“‹ å…Œæ›ç´€éŒ„</h3>
        <div id="loading-text" style="margin:20px 0; color:#888;">è¼‰å…¥ä¸­...</div>
        <ul class="log-list" id="log-list"></ul>
        <button onclick="Admin.close()" style="margin-top:20px; padding:12px 40px; border:none; background:#ff80ab; color:white; font-weight:bold; border-radius:30px; cursor:pointer;">é—œé–‰</button>
    </div>
</div>

<script>
    /* =================================================================
       âš ï¸ è¨­å®šå€
    ================================================================= */
    const DreamloConfig = {
        privateKey: "", 
        publicKey:  "", 
    };

    /* é€šè²¨è†¨è„¹çå“ */
    const REAL_PRIZES = [
        { id: 'tea', name: 'ä¸€æ¯æ‰‹æ–é£²', price: 2500, icon: 'ğŸ§‹' },
        { id: 'massage', name: 'è‚©é ¸æŒ‰æ‘© (20åˆ†)', price: 12000, icon: 'ğŸ’†â€â™€ï¸' },
        { id: 'food', name: 'è«‹åƒå¤§é¤', price: 35000, icon: 'ğŸ½ï¸' },
        { id: 'movie', name: 'é›»å½±ä¹‹å¤œ', price: 50000, icon: 'ğŸ¬' },
        { id: 'wish', name: 'ç„¡æ¢ä»¶é¡˜æœ›åˆ¸', price: 200000, icon: 'ğŸ§â€â™‚ï¸' },
        { id: 'cart', name: 'æ¸…ç©ºè³¼ç‰©è»Š', price: 999999, icon: 'ğŸ›ï¸' }
    ];

    /* =========================================
       1. äº’å‹•èˆ‡ç‰¹æ•ˆ
    ========================================= */
    let userCoins = parseInt(localStorage.getItem('xr_leaf_coins') || 0);

    function updateUI() {
        document.getElementById('total-coins').innerText = userCoins;
        document.getElementById('game-coins').innerText = userCoins;
        localStorage.setItem('xr_leaf_coins', userCoins);
        renderShop();
    }

    // ç„¡å°¾ç†Šé»æ“Šç‰¹æ•ˆ
    let secretClicks = 0;
    function koalaClick(e) {
        // å™´æ„›å¿ƒ
        const heart = document.createElement('div');
        heart.className = 'pop-heart';
        heart.innerText = 'â¤ï¸';
        heart.style.left = e.clientX + 'px';
        heart.style.top = e.clientY + 'px';
        document.body.appendChild(heart);
        setTimeout(() => heart.remove(), 800);

        // ç§˜å¯†é–‹æ› (é»10æ¬¡)
        secretClicks++;
        if(secretClicks === 10) {
            userCoins += 10000;
            updateUI();
            alert("ğŸ¨ ç„¡å°¾ç†Šæ„›å¦³ï¼\nå·å·çµ¦å¦³ 10,000 è‘‰å­è²·é£²æ–™ï½");
            secretClicks = 0;
        }
    }

    function renderShop() {
        const container = document.getElementById('shop-container');
        container.innerHTML = '';
        REAL_PRIZES.forEach(item => {
            const canBuy = userCoins >= item.price;
            const div = document.createElement('div');
            div.className = 'coupon-item';
            div.innerHTML = `
                <div class="coupon-icon">${item.icon}</div>
                <div class="coupon-info">
                    <div class="coupon-name">${item.name}</div>
                    <div class="coupon-price">${item.price.toLocaleString()} è‘‰å­</div>
                </div>
                <button class="btn-redeem" ${canBuy ? '' : 'disabled'} onclick="redeemItem('${item.name}', ${item.price})">
                    ${canBuy ? 'å…Œæ›' : 'ä¸è¶³'}
                </button>
            `;
            container.appendChild(div);
        });
    }

    function redeemItem(itemName, price) {
        if(confirm(`ç¢ºå®šè¦èŠ± ${price} è‘‰å­å…Œæ›ã€Œ${itemName}ã€å—ï¼Ÿ`)) {
            userCoins -= price;
            updateUI();
            Admin.uploadLog(itemName);
            alert(`ğŸ‰ å…Œæ›æˆåŠŸï¼\n\nç²å¾—ï¼š${itemName}\n\n(è¨˜å¾—æˆªåœ–çµ¦ç”·å‹çœ‹å–”ï¼)`);
        }
    }

    /* =========================================
       2. å¾Œå°ç³»çµ±
    ========================================= */
    const Admin = {
        uploadLog: function(itemName) {
            if(!DreamloConfig.privateKey) return;
            const msg = `å…Œæ›ï¼š${itemName}`;
            const score = 2000000000 - Math.floor(Date.now() / 1000); 
            const uniqueName = `${msg}_${Math.floor(Math.random()*100)}`;
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.privateKey}/add/${encodeURIComponent(uniqueName)}/${score}`;
            fetch(url).catch(e => console.log("Upload failed"));
        },
        showLogs: function() {
            document.getElementById('overlay').style.display = 'flex';
            const list = document.getElementById('log-list');
            const loading = document.getElementById('loading-text');
            list.innerHTML = '';
            loading.style.display = 'block';
            if(!DreamloConfig.publicKey) { loading.innerText = "å°šæœªè¨­å®š API Key"; return; }
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.publicKey}/json`;
            fetch(url).then(res => res.json()).then(data => {
                loading.style.display = 'none';
                let entries = [];
                if(data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                    entries = data.dreamlo.leaderboard.entry;
                    if(!Array.isArray(entries)) entries = [entries];
                }
                if(entries.length === 0) { list.innerHTML = '<li>å°šç„¡å…Œæ›ç´€éŒ„</li>'; return; }
                entries.forEach(entry => {
                    let displayName = entry.name.split('_')[0];
                    const li = document.createElement('li');
                    li.className = 'log-item';
                    li.innerHTML = `<span style="font-weight:bold;">${displayName}</span><span>å·²å…Œæ›</span>`;
                    list.appendChild(li);
                });
            }).catch(e => loading.innerText = "è®€å–å¤±æ•—");
        },
        close: function() { document.getElementById('overlay').style.display = 'none'; }
    };

    /* =========================================
       3. é é¢åˆ‡æ›èˆ‡éŠæˆ²
    ========================================= */
    function switchPage(pageId) {
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(`${pageId}-page`).classList.add('active');
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        event.currentTarget.classList.add('active');
        if(pageId === 'shop') updateUI();
    }

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(500, 'sine', 0.1),
        drop: () => Sound.play(300, 'triangle', 0.1),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(500*(1+i*0.2),'sine',0.2), i*60); }
    };

    // é¦¬å¡é¾è‰²ç³»æ–¹å¡Š
    const SHAPES = [
        { m: [[1]], color: '#ff8a80' }, { m: [[1,1]], color: '#ff80ab' }, { m: [[1],[1]], color: '#ea80fc' },
        { m: [[1,1,1]], color: '#b388ff' }, { m: [[1],[1],[1]], color: '#8c9eff' }, { m: [[1,1],[1,1]], color: '#82b1ff' },
        { m: [[1,1,1],[0,1,0]], color: '#80d8ff' }, { m: [[1,0],[1,0],[1,1]], color: '#84ffff' },
        { m: [[1,1,1,1]], color: '#a7ffeb' }, { m: [[1],[1],[1],[1]], color: '#b9f6ca' },
        { m: [[1,1,0],[0,1,1]], color: '#ccff90' }
    ];

    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.TOUCH_OFFSET = 100;
            this.currentShape = null;
            this.ghostShape = null;
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
            this.spawnShapes();
            updateUI();
        }
        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            requestAnimationFrame(this.loop);
        }
        drawGrid() {
            // ç•«å‡ºæ·¡æ·¡çš„ç²‰è‰²ç¶²æ ¼
            this.ctx.strokeStyle = '#fce4ec'; this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }
        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save(); this.ctx.globalAlpha = 0.3;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }
        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) this.drawCell(c, r, this.grid[r][c]);
                }
            }
        }
        // ç¹ªè£½éº»ç³¬æ–¹å¡Š (Mochi Effect)
        drawCell(x, y, color) {
            const padding = 4; 
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2; 
            const cy = y * this.cellSize + this.cellSize/2;
            
            this.ctx.save(); 
            this.ctx.translate(cx, cy);
            
            // 1. ä¸»é«” (è¶…åœ“è§’)
            this.ctx.fillStyle = color;
            this.ctx.beginPath(); 
            this.ctx.roundRect(-size/2, -size/2, size, size, 15); 
            this.ctx.fill();
            
            // 2. å…§éƒ¨æŸ”å…‰ (éœ§é¢æ„Ÿ)
            this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
            this.ctx.beginPath();
            this.ctx.arc(-size/4, -size/4, size/5, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.restore();
        }
        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            for(let i=0; i<3; i++) {
                const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                this.createDraggableShape(shapeData, container);
            }
        }
        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 75; el.height = 75; el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length; const cols = data.m[0].length;
            const size = 13; const offsetX = (75 - cols*size)/2; const offsetY = (75 - rows*size)/2;
            
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) { 
                        const cx = offsetX + c*size + size/2;
                        const cy = offsetY + r*size + size/2;
                        ctx.save(); ctx.translate(cx, cy);
                        ctx.fillStyle = data.color;
                        ctx.beginPath(); ctx.roundRect(-size/2+1, -size/2+1, size-2, size-2, 5); ctx.fill();
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath(); ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                }
            }
            const handleStart = (e) => {
                e.preventDefault(); Sound.pickup(); el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };
            el.addEventListener('mousedown', handleStart); el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }
        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX; const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                el.style.left = (cx - 37.5) + 'px'; el.style.top = (cy - 37.5 - this.TOUCH_OFFSET) + 'px';
                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
                const shape = this.currentShape.data;
                const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);
                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else { this.ghostShape = null; }
            };
            const end = (ev) => {
                document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };
            document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
        }
        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
            const shape = this.currentShape.data;
            const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);
            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove(); Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) setTimeout(() => this.spawnShapes(), 500);
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = ''; this.currentShape.el.style.left = ''; this.currentShape.el.style.top = '';
            }
            this.currentShape = null;
        }
        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c; const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) return false;
                    }
                }
            }
            return true;
        }
        place(shape, x, y) {
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.grid[y+r][x+c] = shape.color;
                }
            }
            this.checkLines();
        }
        checkLines() {
            let rowsToClear = []; let colsToClear = [];
            for(let r=0; r<this.gridSize; r++) if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            for(let c=0; c<this.gridSize; c++) {
                let full = true; for(let r=0; r<this.gridSize; r++) if(this.grid[r][c] === 0) full = false;
                if(full) colsToClear.push(c);
            }
            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                rowsToClear.forEach(r => this.grid[r].fill(0));
                colsToClear.forEach(c => { for(let r=0; r<this.gridSize; r++) this.grid[r][c] = 0; });
                Sound.clear(totalLines);
                let coinsEarned = totalLines * 10;
                if(totalLines > 1) coinsEarned *= totalLines;
                userCoins += coinsEarned;
                updateUI();
                this.showFloatText(`+${coinsEarned} ğŸŒ¿`);
            }
        }
        showFloatText(text) {
            const el = document.createElement('div'); el.className = 'float-text'; el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%'; el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el); setTimeout(() => el.remove(), 1000);
        }
    }
    const game = new BlockPuzzle();
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
