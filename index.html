<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ç„¡å°¾ç†Šè¨±é¡˜æ±  ğŸ¨âœ¨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#aed581">
    
    <!-- å¼•å…¥å¯æ„›åœ“é«” -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #f1f8e9;
            --dot-color: #dcedc8;
            --board-bg: #fff;
            --text-main: #558b2f;
            --accent: #8bc34a;
            --accent-shadow: #689f38;
            --price-color: #ff8a65;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            /* å¯æ„›æ³¢é»èƒŒæ™¯ */
            background-image: radial-gradient(var(--dot-color) 20%, transparent 20%);
            background-position: 0 0;
            background-size: 20px 20px;
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column;
            color: var(--text-main);
        }

        /* === åº•éƒ¨å°èˆªåˆ— (æ¼‚æµ®é›²æœµæ„Ÿ) === */
        .nav-bar {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); 
            padding: 10px 30px; border-radius: 50px;
            display: flex; gap: 40px; 
            box-shadow: 0 10px 25px rgba(85, 139, 47, 0.2);
            border: 2px solid #fff;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .nav-item {
            font-size: 1.6rem; color: #dcedc8; cursor: pointer; transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 55px; height: 55px; display: flex; justify-content: center; align-items: center;
            border-radius: 50%;
        }
        .nav-item.active { 
            background: var(--accent); color: white; 
            transform: translateY(-15px) scale(1.1); 
            box-shadow: 0 5px 0 var(--accent-shadow);
        }

        /* === é é¢å®¹å™¨ === */
        .page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s, transform 0.3s; opacity: 0; pointer-events: none;
        }
        .page.active { opacity: 1; pointer-events: all; transform: scale(1); }

        /* === éŠæˆ²é é¢ === */
        #game-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 20px 20px 110px 20px;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        header { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        
        .score-box {
            background: white; padding: 8px 20px; border-radius: 25px;
            box-shadow: 0 4px 0 #e0e0e0; text-align: center; min-width: 90px;
            border: 2px solid #fff;
        }
        .score-val { font-size: 1.3rem; font-weight: 900; font-family: 'Fredoka'; color: var(--price-color); letter-spacing: 1px; }
        
        /* æ£‹ç›¤è®Šæˆåƒç›¸æ¡†ä¸€æ¨£ */
        #board-container {
            width: 100%; aspect-ratio: 1/1; 
            background: #fff;
            border-radius: 24px; padding: 12px; 
            box-shadow: 0 8px 0 #c5e1a5, 0 15px 20px rgba(0,0,0,0.1);
            border: 4px solid #f1f8e9;
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 16px; display: block; }
        #spawn-area { width: 100%; height: 130px; display: flex; justify-content: space-around; align-items: center; }
        
        .shape-preview { width: 75px; height: 75px; transition: transform 0.1s; filter: drop-shadow(0 4px 0 rgba(0,0,0,0.1)); }
        .shape-preview.dragging { opacity: 0.9; z-index: 2000; position: fixed; transform: scale(1.2); pointer-events: none; }

        /* === å…Œæ›å•†åº—é é¢ === */
        #shop-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 60px 20px 120px 20px;
            display: flex; flex-direction: column; align-items: center;
            overflow-y: auto;
        }
        
        .wallet-card {
            background: linear-gradient(135deg, #aed581, #7cb342);
            color: white; width: 100%; padding: 25px; border-radius: 30px;
            box-shadow: 0 10px 20px rgba(124, 179, 66, 0.3); margin-bottom: 25px;
            display: flex; justify-content: space-between; align-items: center;
            border: 3px solid rgba(255,255,255,0.3);
            position: relative; overflow: hidden;
        }
        /* éŒ¢åŒ…å¡ç‰‡ä¸Šçš„è£é£¾å…‰ */
        .wallet-card::after {
            content: ''; position: absolute; top: -50%; right: -50%; width: 200px; height: 200px;
            background: rgba(255,255,255,0.1); border-radius: 50%;
        }
        .coin-display { font-size: 2.2rem; font-weight: 900; font-family: 'Fredoka'; text-shadow: 0 2px 0 rgba(0,0,0,0.1); }
        
        .shop-list { width: 100%; display: flex; flex-direction: column; gap: 18px; }
        
        .coupon-item {
            background: white; border-radius: 25px; padding: 15px 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 4px 0 #eceff1, 0 8px 15px rgba(0,0,0,0.05); 
            transition: 0.1s; border: 2px solid #fff;
        }
        .coupon-item:active { transform: translateY(4px); box-shadow: 0 0 0 #eceff1; }
        
        .coupon-icon { font-size: 2.8rem; margin-right: 15px; width: 60px; text-align: center; filter: drop-shadow(0 2px 0 rgba(0,0,0,0.1)); }
        .coupon-info { flex: 1; }
        .coupon-name { font-weight: bold; font-size: 1.1rem; color: var(--text-main); margin-bottom: 4px; }
        .coupon-price { 
            color: white; background: var(--price-color); 
            display: inline-block; padding: 3px 10px; border-radius: 15px;
            font-weight: bold; font-size: 0.85rem; font-family: 'Fredoka';
        }
        
        .btn-redeem {
            background: var(--accent); color: white; border: none; padding: 10px 20px;
            border-radius: 25px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 var(--accent-shadow); transition: 0.1s;
        }
        .btn-redeem:active { transform: translateY(4px); box-shadow: none; }
        .btn-redeem:disabled { background: #e0e0e0; box-shadow: none; color: #999; cursor: not-allowed; transform: none; }

        /* === éš±è—çš„å¾Œå°æŒ‰éˆ• === */
        #secret-btn {
            position: fixed; top: 10px; right: 10px; opacity: 0.05; font-size: 1.5rem;
            z-index: 3000; cursor: pointer;
        }

        /* === å½ˆçª— === */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(85, 139, 47, 0.8); z-index: 4000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            display: none; backdrop-filter: blur(5px);
        }
        .overlay-card {
            background: white; padding: 30px; border-radius: 30px; width: 85%; max-width: 400px;
            text-align: center; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .log-list { list-style: none; text-align: left; margin-top: 15px; }
        .log-item { 
            border-bottom: 1px dashed #eee; padding: 12px 0; display: flex; justify-content: space-between;
            font-size: 0.9rem;
        }

        /* æµ®å‹•æ–‡å­— */
        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: var(--price-color); font-size: 2rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 3000;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-50px) scale(1.2); opacity:1; } 100% { transform:translateY(-80px) scale(1); opacity:0; } }
        
        /* æ¨™é¡Œå‹•ç•« */
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        #title-trigger { animation: bounce 2s infinite ease-in-out; }
    </style>
</head>
<body>

<!-- éš±è—å¾Œå°æŒ‰éˆ• -->
<div id="secret-btn" onclick="Admin.showLogs()">â¤ï¸</div>

<!-- å°èˆª -->
<div class="nav-bar">
    <div class="nav-item active" onclick="switchPage('game')">
        <i class="fas fa-gamepad"></i>
    </div>
    <div class="nav-item" onclick="switchPage('shop')">
        <i class="fas fa-gift"></i>
    </div>
</div>

<!-- 1. éŠæˆ²é é¢ -->
<div id="game-page" class="page active">
    <div id="game-wrapper">
        <header>
            <!-- ç§˜å¯†é»æ“Šå€åŸŸï¼šæ¨™é¡Œ -->
            <div id="title-trigger" style="font-weight:900; color:var(--text-main); font-size:1.4rem; cursor:pointer; letter-spacing:1px;">
                <i class="fas fa-koala"></i> ç„¡å°¾ç†Šè¨±é¡˜æ± 
            </div>
            <div class="score-box">
                <div style="font-size:0.7rem; color:#888; font-weight:bold;">LEAVES</div>
                <div class="score-val" id="game-coins">0</div>
            </div>
        </header>

        <div id="board-container">
            <canvas id="game-canvas" width="800" height="800"></canvas>
        </div>
        <div id="spawn-area"></div>
    </div>
</div>

<!-- 2. å…Œæ›å•†åº—é é¢ -->
<div id="shop-page" class="page">
    <div id="shop-wrapper">
        <div class="wallet-card">
            <div>
                <div style="font-size:0.9rem; opacity:0.9; font-weight:bold;">æˆ‘çš„è‘‰å­éŒ¢åŒ…</div>
                <div class="coin-display" id="total-coins">0</div>
            </div>
            <i class="fas fa-leaf" style="font-size:3.5rem; opacity:0.8; transform: rotate(15deg);"></i>
        </div>

        <h3 style="margin-bottom:15px; color:var(--text-main); align-self:flex-start; font-weight:900;">
            <i class="fas fa-star" style="color:#fdd835;"></i> å…Œæ›å¦³çš„é¡˜æœ›
        </h3>
        <div class="shop-list" id="shop-container"></div>
    </div>
</div>

<!-- å¾Œå°å½ˆçª— -->
<div id="overlay">
    <div class="overlay-card">
        <h3 style="color:var(--text-main);">ğŸ“‹ å…Œæ›ç´€éŒ„ (å¾Œå°)</h3>
        <div id="loading-text" style="margin:20px 0; color:#888;">è¼‰å…¥ä¸­...</div>
        <ul class="log-list" id="log-list"></ul>
        <button onclick="Admin.close()" style="margin-top:20px; padding:12px 40px; border:none; background:#f1f8e9; color:var(--text-main); font-weight:bold; border-radius:30px; cursor:pointer;">é—œé–‰</button>
    </div>
</div>

<script>
    /* =================================================================
       âš ï¸ è¨­å®šå€ï¼šè«‹åœ¨æ­¤å¡«å…¥ä½ çš„ Dreamlo Keys
    ================================================================= */
    const DreamloConfig = {
        privateKey: "", 
        publicKey:  "", 
    };

    /* âš ï¸ çå“åˆ—è¡¨ (é€šè²¨è†¨è„¹ç‰ˆ) */
    const REAL_PRIZES = [
        { id: 'tea', name: 'ä¸€æ¯æ‰‹æ–é£²', price: 2500, icon: 'ğŸ§‹' },
        { id: 'massage', name: 'è‚©é ¸æŒ‰æ‘© (20åˆ†)', price: 12000, icon: 'ğŸ’†â€â™€ï¸' },
        { id: 'food', name: 'è«‹åƒå¤§é¤', price: 35000, icon: 'ğŸ½ï¸' },
        { id: 'movie', name: 'é›»å½±ä¹‹å¤œ', price: 50000, icon: 'ğŸ¬' },
        { id: 'wish', name: 'ç„¡æ¢ä»¶é¡˜æœ›åˆ¸', price: 200000, icon: 'ğŸ§â€â™‚ï¸' },
        { id: 'cart', name: 'æ¸…ç©ºè³¼ç‰©è»Š', price: 999999, icon: 'ğŸ›ï¸' }
    ];

    /* =========================================
       1. è³‡æ–™èˆ‡å•†åº—ç³»çµ±
    ========================================= */
    let userCoins = parseInt(localStorage.getItem('xr_leaf_coins') || 0);

    function updateUI() {
        document.getElementById('total-coins').innerText = userCoins;
        document.getElementById('game-coins').innerText = userCoins;
        localStorage.setItem('xr_leaf_coins', userCoins);
        renderShop();
    }

    function renderShop() {
        const container = document.getElementById('shop-container');
        container.innerHTML = '';
        REAL_PRIZES.forEach(item => {
            const canBuy = userCoins >= item.price;
            const div = document.createElement('div');
            div.className = 'coupon-item';
            div.innerHTML = `
                <div class="coupon-icon">${item.icon}</div>
                <div class="coupon-info">
                    <div class="coupon-name">${item.name}</div>
                    <div class="coupon-price">${item.price.toLocaleString()} è‘‰å­</div>
                </div>
                <button class="btn-redeem" ${canBuy ? '' : 'disabled'} onclick="redeemItem('${item.name}', ${item.price})">
                    ${canBuy ? 'å…Œæ›' : 'ä¸è¶³'}
                </button>
            `;
            container.appendChild(div);
        });
    }

    function redeemItem(itemName, price) {
        if(confirm(`ç¢ºå®šè¦èŠ± ${price} è‘‰å­å…Œæ›ã€Œ${itemName}ã€å—ï¼Ÿ`)) {
            userCoins -= price;
            updateUI();
            Admin.uploadLog(itemName);
            alert(`ğŸ‰ å…Œæ›æˆåŠŸï¼\n\nå¦³ç²å¾—äº†ï¼š${itemName}\n\n(ç³»çµ±å·²å·å·é€šçŸ¥ç”·å‹æº–å‚™å±¥ç´„)`);
        }
    }

    /* ç§˜å¯†é–‹æ›åŠŸèƒ½ */
    let clickCount = 0;
    document.getElementById('title-trigger').addEventListener('click', () => {
        clickCount++;
        if(clickCount === 10) {
            userCoins += 10000;
            updateUI();
            alert("ğŸ¨ ç„¡å°¾ç†Šå ±æ©ï¼\nå·²å·å·åŒ¯å…¥ 10,000 è‘‰å­ã€‚");
            clickCount = 0;
        }
    });

    /* =========================================
       2. å¾Œå°ç³»çµ±
    ========================================= */
    const Admin = {
        uploadLog: function(itemName) {
            if(!DreamloConfig.privateKey) return;
            const msg = `å…Œæ›ï¼š${itemName}`;
            const score = 2000000000 - Math.floor(Date.now() / 1000); 
            const uniqueName = `${msg}_${Math.floor(Math.random()*100)}`;
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.privateKey}/add/${encodeURIComponent(uniqueName)}/${score}`;
            fetch(url).catch(e => console.log("Upload failed"));
        },
        showLogs: function() {
            document.getElementById('overlay').style.display = 'flex';
            const list = document.getElementById('log-list');
            const loading = document.getElementById('loading-text');
            list.innerHTML = '';
            loading.style.display = 'block';
            if(!DreamloConfig.publicKey) { loading.innerText = "å°šæœªè¨­å®š API Key"; return; }
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.publicKey}/json`;
            fetch(url).then(res => res.json()).then(data => {
                loading.style.display = 'none';
                let entries = [];
                if(data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                    entries = data.dreamlo.leaderboard.entry;
                    if(!Array.isArray(entries)) entries = [entries];
                }
                if(entries.length === 0) { list.innerHTML = '<li>å°šç„¡å…Œæ›ç´€éŒ„</li>'; return; }
                entries.forEach(entry => {
                    let displayName = entry.name.split('_')[0];
                    const li = document.createElement('li');
                    li.className = 'log-item';
                    li.innerHTML = `<span style="font-weight:bold; color:#33691e;">${displayName}</span><span style="color:#f57f17;">å·²å…Œæ›</span>`;
                    list.appendChild(li);
                });
            }).catch(e => loading.innerText = "è®€å–å¤±æ•—");
        },
        close: function() { document.getElementById('overlay').style.display = 'none'; }
    };

    /* =========================================
       3. é é¢åˆ‡æ›èˆ‡éŠæˆ²
    ========================================= */
    function switchPage(pageId) {
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(`${pageId}-page`).classList.add('active');
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        event.currentTarget.classList.add('active');
        if(pageId === 'shop') updateUI();
    }

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(400, 'sine', 0.1),
        drop: () => Sound.play(200, 'triangle', 0.1),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(440*(1+i*0.5),'sine',0.3), i*50); }
    };

    // æœå‡è‰²ç³»æ–¹å¡Š
    const SHAPES = [
        { m: [[1]], color: '#aed581' }, { m: [[1,1]], color: '#8bc34a' }, { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1,1]], color: '#689f38' }, { m: [[1],[1],[1]], color: '#689f38' }, { m: [[1,1],[1,1]], color: '#ffb74d' },
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' }, { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' },
        { m: [[1,1,1,1]], color: '#558b2f' }, { m: [[1],[1],[1],[1]], color: '#558b2f' },
        { m: [[1,1,0],[0,1,1]], color: '#ba68c8' }
    ];

    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.TOUCH_OFFSET = 100;
            this.currentShape = null;
            this.ghostShape = null;
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
            this.spawnShapes();
            updateUI();
        }
        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            requestAnimationFrame(this.loop);
        }
        drawGrid() {
            // ç•«å‡ºæ·¡æ·¡çš„ç¶²æ ¼
            this.ctx.strokeStyle = '#f1f8e9'; this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }
        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save(); this.ctx.globalAlpha = 0.3;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }
        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) this.drawCell(c, r, this.grid[r][c]);
                }
            }
        }
        // ç¹ªè£½æœå‡æ–¹å¡Š (Jelly Effect)
        drawCell(x, y, color) {
            const padding = 3; 
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2; 
            const cy = y * this.cellSize + this.cellSize/2;
            
            this.ctx.save(); 
            this.ctx.translate(cx, cy);
            
            // 1. ä¸»é«”
            this.ctx.fillStyle = color;
            this.ctx.beginPath(); 
            this.ctx.roundRect(-size/2, -size/2, size, size, 12); // æ›´åœ“çš„è§’
            this.ctx.fill();
            
            // 2. å…§éƒ¨é«˜å…‰ (è®“å®ƒçœ‹èµ·ä¾†å‡¸å‡¸çš„)
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -size/4, size/2.5, size/5, 0, 0, Math.PI*2);
            this.ctx.fill();

            // 3. å·¦ä¸Šè§’äº®é» (åå…‰)
            this.ctx.fillStyle = 'rgba(255,255,255,0.6)';
            this.ctx.beginPath();
            this.ctx.arc(-size/3.5, -size/3.5, size/10, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.restore();
        }
        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            for(let i=0; i<3; i++) {
                const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                this.createDraggableShape(shapeData, container);
            }
        }
        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 75; el.height = 75; el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length; const cols = data.m[0].length;
            const size = 13; const offsetX = (75 - cols*size)/2; const offsetY = (75 - rows*size)/2;
            
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) { 
                        // é è¦½æ™‚ä¹Ÿè¦ç•«æœå‡
                        const cx = offsetX + c*size + size/2;
                        const cy = offsetY + r*size + size/2;
                        ctx.save(); ctx.translate(cx, cy);
                        ctx.fillStyle = data.color;
                        ctx.beginPath(); ctx.roundRect(-size/2+1, -size/2+1, size-2, size-2, 4); ctx.fill();
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath(); ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                }
            }
            const handleStart = (e) => {
                e.preventDefault(); Sound.pickup(); el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };
            el.addEventListener('mousedown', handleStart); el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }
        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX; const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                el.style.left = (cx - 37.5) + 'px'; el.style.top = (cy - 37.5 - this.TOUCH_OFFSET) + 'px';
                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
                const shape = this.currentShape.data;
                const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);
                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else { this.ghostShape = null; }
            };
            const end = (ev) => {
                document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };
            document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
        }
        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
            const shape = this.currentShape.data;
            const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);
            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove(); Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) setTimeout(() => this.spawnShapes(), 500);
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = ''; this.currentShape.el.style.left = ''; this.currentShape.el.style.top = '';
            }
            this.currentShape = null;
        }
        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c; const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) return false;
                    }
                }
            }
            return true;
        }
        place(shape, x, y) {
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.grid[y+r][x+c] = shape.color;
                }
            }
            this.checkLines();
        }
        checkLines() {
            let rowsToClear = []; let colsToClear = [];
            for(let r=0; r<this.gridSize; r++) if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            for(let c=0; c<this.gridSize; c++) {
                let full = true; for(let r=0; r<this.gridSize; r++) if(this.grid[r][c] === 0) full = false;
                if(full) colsToClear.push(c);
            }
            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                rowsToClear.forEach(r => this.grid[r].fill(0));
                colsToClear.forEach(c => { for(let r=0; r<this.gridSize; r++) this.grid[r][c] = 0; });
                Sound.clear(totalLines);
                let coinsEarned = totalLines * 10;
                if(totalLines > 1) coinsEarned *= totalLines;
                userCoins += coinsEarned;
                updateUI();
                this.showFloatText(`+${coinsEarned} ğŸŒ¿`);
            }
        }
        showFloatText(text) {
            const el = document.createElement('div'); el.className = 'float-text'; el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%'; el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el); setTimeout(() => el.remove(), 1000);
        }
    }
    const game = new BlockPuzzle();
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
