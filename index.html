<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ç„¡å°¾ç†Šçš„å°å±‹ Â· Koala Home</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#558b2f">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #f1f8e9;
            --board-bg: #dcedc8;
            --text-main: #33691e;
            --accent: #ffb74d;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column;
            color: var(--text-main);
        }

        /* === åº•éƒ¨å°èˆªåˆ— === */
        .nav-bar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: white; padding: 10px 20px; border-radius: 40px;
            display: flex; gap: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .nav-item {
            font-size: 1.5rem; color: #ccc; cursor: pointer; transition: 0.3s;
            width: 50px; height: 50px; display: flex; justify-content: center; align-items: center;
            border-radius: 50%;
        }
        .nav-item.active { background: #8bc34a; color: white; transform: translateY(-10px); box-shadow: 0 5px 15px rgba(139, 195, 74, 0.4); }

        /* === é é¢å®¹å™¨ === */
        .page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s, transform 0.3s; opacity: 0; pointer-events: none;
        }
        .page.active { opacity: 1; pointer-events: all; transform: scale(1); }

        /* === éŠæˆ²é é¢ === */
        #game-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 20px 20px 100px 20px;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        header { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        .score-box {
            background: white; padding: 8px 15px; border-radius: 20px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.05); text-align: center; min-width: 80px;
        }
        .score-val { font-size: 1.2rem; font-weight: 900; font-family: 'Fredoka'; }
        
        #board-container {
            width: 100%; aspect-ratio: 1/1; background: var(--board-bg);
            border-radius: 16px; padding: 10px; box-shadow: inset 0 5px 15px rgba(0,0,0,0.1);
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 8px; display: block; }
        #spawn-area { width: 100%; height: 120px; display: flex; justify-content: space-around; align-items: center; }
        
        .shape-preview { width: 70px; height: 70px; transition: transform 0.1s; }
        .shape-preview.dragging { opacity: 0.9; z-index: 2000; position: fixed; transform: scale(1.2); pointer-events: none; }

        /* === å°å±‹é é¢ (å•†åº—) === */
        #home-wrapper {
            width: 100%; max-width: 500px; height: 100%; padding: 60px 20px 100px 20px;
            display: flex; flex-direction: column; align-items: center;
            overflow-y: auto;
        }
        
        /* ç„¡å°¾ç†Šå±•ç¤ºå€ */
        .koala-room {
            width: 200px; height: 200px; background: #fff9c4;
            border-radius: 50%; border: 5px solid white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 30px; position: relative;
        }
        .room-decor { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        
        /* éŒ¢åŒ…é¡¯ç¤º */
        .wallet {
            background: #fff; padding: 10px 25px; border-radius: 30px;
            font-weight: bold; color: #f57f17; margin-bottom: 20px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.05); display: flex; align-items: center; gap: 10px;
        }

        /* å•†åº—ç¶²æ ¼ */
        .shop-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 100%;
        }
        .shop-item {
            background: white; border-radius: 15px; padding: 15px;
            text-align: center; cursor: pointer; transition: 0.2s;
            border: 2px solid transparent; position: relative;
        }
        .shop-item.locked { opacity: 0.6; filter: grayscale(1); }
        .shop-item.owned { border-color: #aed581; background: #f1f8e9; }
        .shop-item.equipped { border-color: #558b2f; background: #dcedc8; box-shadow: 0 0 0 2px #558b2f; }
        
        .item-icon { font-size: 2rem; margin-bottom: 5px; }
        .item-price { font-size: 0.8rem; font-weight: bold; color: #f57f17; }
        .item-name { font-size: 0.8rem; color: #555; margin-bottom: 5px; }

        /* === SVG æ¨£å¼ === */
        #koala-svg { width: 140px; height: 140px; }
        .svg-accessory { display: none; } /* é è¨­éš±è—é£¾å“ */

        /* æµ®å‹•æ–‡å­— */
        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff8f00; font-size: 2rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 3000;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-50px) scale(1.2); opacity:1; } 100% { transform:translateY(-80px) scale(1); opacity:0; } }
    </style>
</head>
<body>

<!-- åº•éƒ¨å°èˆª -->
<div class="nav-bar">
    <div class="nav-item active" onclick="switchPage('game')">
        <i class="fas fa-gamepad"></i>
    </div>
    <div class="nav-item" onclick="switchPage('home')">
        <i class="fas fa-home"></i>
    </div>
</div>

<!-- 1. éŠæˆ²é é¢ -->
<div id="game-page" class="page active">
    <div id="game-wrapper">
        <header>
            <div class="score-box">
                <div style="font-size:0.7rem; color:#888;">SCORE</div>
                <div class="score-val" id="score">0</div>
            </div>
            <div style="font-weight:bold; color:#558b2f;">è³ºè‘‰å­é¤Šç„¡å°¾ç†Š ğŸŒ¿</div>
            <div class="score-box">
                <div style="font-size:0.7rem; color:#888;">LEAVES</div>
                <div class="score-val" style="color:#f57f17;" id="game-leaves">0</div>
            </div>
        </header>

        <div id="board-container">
            <canvas id="game-canvas" width="800" height="800"></canvas>
        </div>
        <div id="spawn-area"></div>
    </div>
</div>

<!-- 2. å°å±‹é é¢ -->
<div id="home-page" class="page">
    <div id="home-wrapper">
        <div class="wallet">
            <i class="fas fa-leaf"></i> <span id="total-leaves">0</span>
        </div>

        <div class="koala-room">
            <!-- æˆ¿é–“è£é£¾å±¤ -->
            <div class="room-decor" id="decor-layer"></div>
            
            <!-- ç„¡å°¾ç†Šæœ¬é«” -->
            <svg id="koala-svg" viewBox="0 0 100 100">
                <!-- èº«é«” -->
                <ellipse cx="50" cy="70" rx="35" ry="28" fill="#9e9e9e"/>
                <ellipse cx="50" cy="70" rx="20" ry="18" fill="#e0e0e0"/>
                <!-- é ­ -->
                <circle cx="50" cy="40" r="28" fill="#9e9e9e"/>
                <!-- è€³æœµ -->
                <circle cx="25" cy="30" r="10" fill="#9e9e9e"/>
                <circle cx="75" cy="30" r="10" fill="#9e9e9e"/>
                <circle cx="25" cy="30" r="6" fill="#f5f5f5"/>
                <circle cx="75" cy="30" r="6" fill="#f5f5f5"/>
                <!-- è‡‰ -->
                <circle cx="42" cy="38" r="3" fill="#333"/>
                <circle cx="58" cy="38" r="3" fill="#333"/>
                <ellipse cx="50" cy="45" rx="6" ry="8" fill="#424242"/>
                <circle cx="35" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                <circle cx="65" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                
                <!-- === é£¾å“å±¤ (é è¨­éš±è—) === -->
                <!-- è´è¶çµ -->
                <g id="acc-bow" class="svg-accessory">
                    <path d="M40 70 L30 60 L30 80 Z" fill="#e91e63"/>
                    <path d="M60 70 L70 60 L70 80 Z" fill="#e91e63"/>
                    <circle cx="50" cy="70" r="5" fill="#c2185b"/>
                </g>
                <!-- èŠ±æœµ -->
                <g id="acc-flower" class="svg-accessory">
                    <circle cx="25" cy="25" r="8" fill="#ffeb3b"/>
                    <circle cx="25" cy="25" r="3" fill="#f57f17"/>
                </g>
                <!-- å¸½å­ -->
                <g id="acc-hat" class="svg-accessory">
                    <path d="M30 20 L70 20 L60 5 L40 5 Z" fill="#3e2723"/>
                    <rect x="25" y="20" width="50" height="5" fill="#3e2723"/>
                </g>
                <!-- çœ¼é¡ -->
                <g id="acc-glasses" class="svg-accessory">
                    <circle cx="42" cy="38" r="7" stroke="#333" stroke-width="2" fill="none"/>
                    <circle cx="58" cy="38" r="7" stroke="#333" stroke-width="2" fill="none"/>
                    <line x1="49" y1="38" x2="51" y2="38" stroke="#333" stroke-width="2"/>
                </g>
            </svg>
        </div>

        <h3 style="margin-bottom:15px; color:#558b2f;">ç„¡å°¾ç†Šç™¾è²¨</h3>
        <div class="shop-grid" id="shop-container">
            <!-- JS ç”Ÿæˆå•†å“ -->
        </div>
    </div>
</div>

<script>
    /* =========================================
       1. éŠæˆ²è³‡æ–™èˆ‡å•†åº—ç³»çµ±
    ========================================= */
    const GameData = {
        leaves: parseInt(localStorage.getItem('xr_leaves') || 0),
        inventory: JSON.parse(localStorage.getItem('xr_inventory') || '[]'),
        equipped: JSON.parse(localStorage.getItem('xr_equipped') || '{}')
    };

    const SHOP_ITEMS = [
        { id: 'bow', name: 'ç²‰ç´…é ˜çµ', price: 100, icon: 'ğŸ€', type: 'svg' },
        { id: 'flower', name: 'å°èŠ±æœµ', price: 250, icon: 'ğŸŒ¸', type: 'svg' },
        { id: 'glasses', name: 'æ–‡é’çœ¼é¡', price: 500, icon: 'ğŸ‘“', type: 'svg' },
        { id: 'hat', name: 'ç´³å£«å¸½', price: 800, icon: 'ğŸ©', type: 'svg' },
        { id: 'rug', name: 'æ„›å¿ƒæ¯¯', price: 300, icon: 'ğŸ§¶', type: 'decor', html: '<div style="position:absolute;bottom:10px;left:50%;transform:translateX(-50%);font-size:3rem;">ğŸ§¶</div>' },
        { id: 'lamp', name: 'å°æª¯ç‡ˆ', price: 600, icon: 'ğŸ’¡', type: 'decor', html: '<div style="position:absolute;top:20px;right:20px;font-size:2rem;">ğŸ’¡</div>' }
    ];

    function updateWallet() {
        document.getElementById('total-leaves').innerText = GameData.leaves;
        document.getElementById('game-leaves').innerText = GameData.leaves;
        localStorage.setItem('xr_leaves', GameData.leaves);
    }

    function renderShop() {
        const container = document.getElementById('shop-container');
        container.innerHTML = '';
        
        SHOP_ITEMS.forEach(item => {
            const owned = GameData.inventory.includes(item.id);
            const equipped = GameData.equipped[item.type] === item.id;
            
            const div = document.createElement('div');
            div.className = `shop-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}`;
            if (!owned && GameData.leaves < item.price) div.classList.add('locked');
            
            div.innerHTML = `
                <div class="item-icon">${item.icon}</div>
                <div class="item-name">${item.name}</div>
                <div class="item-price">${owned ? (equipped ? 'ä½¿ç”¨ä¸­' : 'å·²æ“æœ‰') : item.price + ' ğŸŒ¿'}</div>
            `;
            
            div.onclick = () => buyOrEquip(item);
            container.appendChild(div);
        });
        
        updateCharacter();
    }

    function buyOrEquip(item) {
        if (GameData.inventory.includes(item.id)) {
            // è£å‚™æˆ–å¸ä¸‹
            if (GameData.equipped[item.type] === item.id) {
                delete GameData.equipped[item.type]; // å¸ä¸‹
            } else {
                GameData.equipped[item.type] = item.id; // è£å‚™
            }
            localStorage.setItem('xr_equipped', JSON.stringify(GameData.equipped));
            renderShop();
        } else {
            // è³¼è²·
            if (GameData.leaves >= item.price) {
                if(confirm(`è¦èŠ± ${item.price} è‘‰å­è²· ${item.name} å—ï¼Ÿ`)) {
                    GameData.leaves -= item.price;
                    GameData.inventory.push(item.id);
                    localStorage.setItem('xr_leaves', GameData.leaves);
                    localStorage.setItem('xr_inventory', JSON.stringify(GameData.inventory));
                    updateWallet();
                    renderShop();
                    Sound.buy();
                }
            } else {
                alert("è‘‰å­ä¸å¤ å–”ï¼å¿«å»ç©éŠæˆ²è³ºéŒ¢ï½");
            }
        }
    }

    function updateCharacter() {
        // é‡ç½® SVG é£¾å“
        document.querySelectorAll('.svg-accessory').forEach(el => el.style.display = 'none');
        // é‡ç½® æˆ¿é–“è£é£¾
        document.getElementById('decor-layer').innerHTML = '';

        // é¡¯ç¤ºè£å‚™ä¸­çš„ç‰©å“
        if (GameData.equipped['svg']) {
            document.getElementById(`acc-${GameData.equipped['svg']}`).style.display = 'block';
        }
        if (GameData.equipped['decor']) {
            const item = SHOP_ITEMS.find(i => i.id === GameData.equipped['decor']);
            if(item) document.getElementById('decor-layer').innerHTML = item.html;
        }
    }

    /* =========================================
       2. é é¢åˆ‡æ›é‚è¼¯
    ========================================= */
    function switchPage(pageId) {
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(`${pageId}-page`).classList.add('active');
        
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        event.currentTarget.classList.add('active');

        if(pageId === 'home') {
            updateWallet();
            renderShop();
        }
    }

    /* =========================================
       3. éŠæˆ²å¼•æ“ (Block Puzzle)
    ========================================= */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(400, 'sine', 0.1),
        drop: () => Sound.play(200, 'triangle', 0.1),
        buy: () => Sound.play(600, 'square', 0.2),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(440*(1+i*0.5),'sine',0.3), i*50); }
    };

    const SHAPES = [
        { m: [[1]], color: '#aed581' }, { m: [[1,1]], color: '#8bc34a' }, { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1,1]], color: '#689f38' }, { m: [[1],[1],[1]], color: '#689f38' }, { m: [[1,1],[1,1]], color: '#ffb74d' },
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' }, { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' },
        { m: [[1,1,1,1]], color: '#558b2f' }, { m: [[1],[1],[1],[1]], color: '#558b2f' }
    ];

    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.TOUCH_OFFSET = 100;
            this.currentShape = null;
            this.ghostShape = null;
            
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
            this.spawnShapes();
            updateWallet();
            updateCharacter(); // åˆå§‹åŒ–è§’è‰²å¤–è§€
        }

        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            requestAnimationFrame(this.loop);
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)'; this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }

        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save(); this.ctx.globalAlpha = 0.4;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }

        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) this.drawCell(c, r, this.grid[r][c]);
                }
            }
        }

        drawCell(x, y, color) {
            const padding = 4; const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2; const cy = y * this.cellSize + this.cellSize/2;
            this.ctx.save(); this.ctx.translate(cx, cy);
            this.ctx.fillStyle = color;
            this.ctx.beginPath(); this.ctx.roundRect(-size/2, -size/2, size, size, 10); this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath(); this.ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2); this.ctx.fill();
            this.ctx.restore();
        }

        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            for(let i=0; i<3; i++) {
                const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                this.createDraggableShape(shapeData, container);
            }
        }

        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 70; el.height = 70; el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length; const cols = data.m[0].length;
            const size = 12; const offsetX = (70 - cols*size)/2; const offsetY = (70 - rows*size)/2;
            ctx.fillStyle = data.color;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) { ctx.beginPath(); ctx.roundRect(offsetX + c*size, offsetY + r*size, size-2, size-2, 3); ctx.fill(); }
                }
            }
            const handleStart = (e) => {
                e.preventDefault(); Sound.pickup(); el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };
            el.addEventListener('mousedown', handleStart); el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }

        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX; const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                el.style.left = (cx - 35) + 'px'; el.style.top = (cy - 35 - this.TOUCH_OFFSET) + 'px';
                
                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
                const shape = this.currentShape.data;
                const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);

                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else { this.ghostShape = null; }
            };
            const end = (ev) => {
                document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };
            document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
        }

        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize); const gy = Math.floor(y / this.cellSize);
            const shape = this.currentShape.data;
            const finalX = gx - Math.floor(shape.m[0].length/2); const finalY = gy - Math.floor(shape.m.length/2);

            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove(); Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) setTimeout(() => this.spawnShapes(), 500);
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = ''; this.currentShape.el.style.left = ''; this.currentShape.el.style.top = '';
            }
            this.currentShape = null;
        }

        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c; const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) return false;
                    }
                }
            }
            return true;
        }

        place(shape, x, y) {
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.grid[y+r][x+c] = shape.color;
                }
            }
            this.updateScore(10);
            this.checkLines();
        }

        checkLines() {
            let rowsToClear = []; let colsToClear = [];
            for(let r=0; r<this.gridSize; r++) if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            for(let c=0; c<this.gridSize; c++) {
                let full = true; for(let r=0; r<this.gridSize; r++) if(this.grid[r][c] === 0) full = false;
                if(full) colsToClear.push(c);
            }
            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                rowsToClear.forEach(r => this.grid[r].fill(0));
                colsToClear.forEach(c => { for(let r=0; r<this.gridSize; r++) this.grid[r][c] = 0; });
                
                Sound.clear(totalLines);
                let points = totalLines * 100 * totalLines;
                this.updateScore(points);
                
                // çå‹µè‘‰å­
                let leavesEarned = totalLines * 5; // æ¯ä¸€è¡Œçµ¦ 5 è‘‰å­
                if(totalLines > 1) leavesEarned *= 2; // Combo åŠ å€
                this.earnLeaves(leavesEarned);
                
                this.showFloatText(`+${leavesEarned} ğŸŒ¿`);
            }
        }

        updateScore(points) {
            this.score += points;
            document.getElementById('score').innerText = this.score;
        }
        
        earnLeaves(amount) {
            GameData.leaves += amount;
            updateWallet();
        }

        showFloatText(text) {
            const el = document.createElement('div'); el.className = 'float-text'; el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%'; el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el); setTimeout(() => el.remove(), 1000);
        }
    }

    const game = new BlockPuzzle();
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
