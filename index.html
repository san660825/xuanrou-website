<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ç„¡å°¾ç†Šæ‹¼åœ–ï¼šå…¨çƒé€£ç·šç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#558b2f">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #f1f8e9;
            --board-bg: #dcedc8;
            --text-main: #33691e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--text-main);
        }

        #game-wrapper {
            position: relative; width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 20px;
        }

        header {
            width: 100%; display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; padding: 0 10px;
        }
        .score-box {
            background: white; padding: 8px 15px; border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center;
            min-width: 90px;
        }
        .score-label { font-size: 0.7rem; color: #888; font-weight: bold; }
        .score-val { font-size: 1.2rem; font-weight: 900; color: var(--text-main); font-family: 'Fredoka'; }

        #koala-mascot {
            width: 70px; height: 70px; transition: transform 0.3s;
        }
        .koala-panic { animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, -1px); } }

        #board-container {
            position: relative; width: 100%; aspect-ratio: 1/1;
            background: var(--board-bg); border-radius: 16px;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.1); padding: 10px;
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 8px; display: block; }

        #spawn-area {
            width: 100%; height: 140px; display: flex; justify-content: space-around; align-items: center;
        }
        .shape-preview {
            width: 80px; height: 80px; position: relative; transition: transform 0.1s;
        }
        .shape-preview.dragging {
            opacity: 0.9; z-index: 1000; position: fixed; pointer-events: none;
            transform: scale(1.1); filter: drop-shadow(0 30px 50px rgba(0,0,0,0.3));
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        .rank-btn {
            position: absolute; top: 20px; right: 20px;
            background: #fbc02d; color: white; border: none; padding: 8px 15px;
            border-radius: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 #f57f17; z-index: 100;
        }
        
        #overlay, #rank-overlay, #name-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(85, 139, 47, 0.95); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s;
        }
        #rank-overlay { background: rgba(0,0,0,0.85); display: none; }
        #name-overlay { background: rgba(0,0,0,0.85); display: none; z-index: 3000; }
        
        .overlay-card {
            background: white; padding: 30px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            width: 85%; max-width: 400px;
        }

        .mode-select {
            display: flex; flex-direction: column; gap: 15px; margin-top: 20px;
        }
        .btn-mode {
            border: none; padding: 15px; font-size: 1.2rem; border-radius: 50px;
            cursor: pointer; font-family: 'Zen Maru Gothic'; font-weight: bold;
            transition: 0.2s; color: white; position: relative; overflow: hidden;
        }
        .btn-easy { background: #8bc34a; box-shadow: 0 5px 0 #558b2f; }
        .btn-hard { background: #e53935; box-shadow: 0 5px 0 #b71c1c; }
        .btn-mode:active { transform: translateY(5px); box-shadow: none; }
        
        .rank-list { list-style: none; text-align: left; margin: 20px 0; max-height: 300px; overflow-y: auto; }
        .rank-item { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #eee; }
        .rank-item:nth-child(1) { color: #fbc02d; font-weight: 900; font-size: 1.1em; }
        .rank-item:nth-child(2) { color: #9e9e9e; font-weight: bold; }
        .rank-item:nth-child(3) { color: #a1887f; font-weight: bold; }
        
        .btn-close { background: #ccc; color: #555; border: none; padding: 10px 30px; border-radius: 20px; margin-top: 10px; }
        
        /* è¼¸å…¥åå­— */
        input.name-input {
            padding: 10px; border: 2px solid #aed581; border-radius: 10px;
            font-size: 1.2rem; text-align: center; width: 80%; margin: 15px 0;
            outline: none; font-family: 'Zen Maru Gothic';
        }
        .btn-submit { background: #4db6ac; color: white; border: none; padding: 10px 30px; border-radius: 20px; }

        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff8f00; font-size: 2.5rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 99;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-30px) scale(1.2); opacity:1; } 100% { transform:translateY(-60px) scale(1); opacity:0; } }
    </style>
</head>
<body>

<button class="rank-btn" onclick="Leaderboard.show()">ğŸ† æ’è¡Œæ¦œ</button>

<!-- éŠæˆ²é–‹å§‹/æ¨¡å¼é¸æ“‡ -->
<div id="overlay">
    <div class="overlay-card">
        <h1 style="color: #558b2f; margin-bottom: 5px;">ç„¡å°¾ç†Šæ‹¼åœ–</h1>
        <p style="color: #888; font-size: 0.9rem;">ç‘„æŸ”ï¼Œä»Šå¤©æƒ³ç©å“ªä¸€ç¨®ï¼Ÿ</p>
        
        <div id="final-score" style="font-size: 1.5rem; font-weight: bold; color: #f57f17; display: none; margin: 15px 0;">
            0 åˆ†
        </div>

        <div class="mode-select">
            <button class="btn-mode btn-easy" onclick="game.start('easy')">
                <i class="fas fa-coffee"></i> è¼•é¬†æ¨¡å¼
                <div style="font-size: 0.7rem; opacity: 0.8;">ç„¡ç‚¸å½ˆ Â· ç´”æ”¾é¬†</div>
            </button>
            <button class="btn-mode btn-hard" onclick="game.start('hard')">
                <i class="fas fa-fire"></i> åœ°ç„æ¨¡å¼
                <div style="font-size: 0.7rem; opacity: 0.8;">ç‚¸å½ˆå€’æ•¸ Â· å…¨çƒæ’å</div>
            </button>
        </div>
    </div>
</div>

<!-- æ’è¡Œæ¦œ -->
<div id="rank-overlay">
    <div class="overlay-card">
        <h2>ğŸ† çœŸå¯¦å…¨çƒæ¦œ (åœ°ç„)</h2>
        <div id="rank-loading" style="color:#888;">è¼‰å…¥ä¸­...</div>
        <ul class="rank-list" id="rank-list"></ul>
        <button class="btn-close" onclick="Leaderboard.close()">é—œé–‰</button>
    </div>
</div>

<!-- è¼¸å…¥åå­— -->
<div id="name-overlay">
    <div class="overlay-card">
        <h2>ğŸ‰ æ–°ç´€éŒ„ï¼</h2>
        <p>å¦³å¤ªå²å®³äº†ï¼è«‹è¼¸å…¥æš±ç¨±ï¼š</p>
        <input type="text" id="player-name" class="name-input" placeholder="ä¾‹å¦‚ï¼šç‘„æŸ”" maxlength="10">
        <button class="btn-submit" onclick="Leaderboard.submit()">ä¸Šå‚³æˆç¸¾</button>
    </div>
</div>

<div id="game-wrapper">
    <header>
        <div class="score-box">
            <span class="score-label">SCORE</span>
            <span class="score-val" id="score">0</span>
        </div>
        <div id="koala-mascot">
            <svg viewBox="0 0 80 80">
                <circle cx="15" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="65" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="15" cy="25" r="8" fill="#f5f5f5"/>
                <circle cx="65" cy="25" r="8" fill="#f5f5f5"/>
                <ellipse cx="40" cy="40" rx="32" ry="28" fill="#9e9e9e"/>
                <circle cx="28" cy="35" r="3" fill="#333"/>
                <circle cx="52" cy="35" r="3" fill="#333"/>
                <ellipse cx="40" cy="42" rx="8" ry="10" fill="#424242"/>
                <path class="mouth" d="M35 55 Q40 60 45 55" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                <circle cx="20" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                <circle cx="60" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
            </svg>
        </div>
        <div class="score-box">
            <span class="score-label">BEST</span>
            <span class="score-val" id="best-score">0</span>
        </div>
    </header>

    <div id="board-container">
        <canvas id="game-canvas" width="800" height="800"></canvas>
    </div>
    <div id="spawn-area"></div>
</div>

<script>
    /* =================================================================
       âš ï¸ è¨­å®šå€ï¼šè«‹åœ¨æ­¤å¡«å…¥ Dreamlo.com çš„ä»£ç¢¼
       1. å» http://dreamlo.com/ é»æ“ŠæŒ‰éˆ•
       2. è¤‡è£½ Private Code è²¼åˆ°ä¸‹æ–¹ privateKey
       3. è¤‡è£½ Public Code è²¼åˆ°ä¸‹æ–¹ publicKey
    ================================================================= */
    const DreamloConfig = {
        privateKey: "", // ç¯„ä¾‹: "7s8d6f8s7d6f8s7d6f..." (ä¸Šå‚³ç”¨)
        publicKey:  "", // ç¯„ä¾‹: "5f5e5d5c..." (è®€å–ç”¨)
    };

    /* 1. æ’è¡Œæ¦œç®¡ç†å™¨ */
    const Leaderboard = {
        show: function() {
            document.getElementById('rank-overlay').style.display = 'flex';
            this.fetchScores();
        },
        close: function() {
            document.getElementById('rank-overlay').style.display = 'none';
        },
        fetchScores: function() {
            const list = document.getElementById('rank-list');
            const loading = document.getElementById('rank-loading');
            list.innerHTML = '';
            loading.style.display = 'block';

            if(!DreamloConfig.publicKey) {
                loading.innerText = "å°šæœªè¨­å®šæ’è¡Œæ¦œé‡‘é‘° (è«‹çœ‹ç¨‹å¼ç¢¼èªªæ˜)";
                return;
            }

            // ä½¿ç”¨ Dreamlo API
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.publicKey}/json`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    loading.style.display = 'none';
                    let scores = [];
                    
                    if (data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                        let entries = data.dreamlo.leaderboard.entry;
                        // å¦‚æœåªæœ‰ä¸€ç­†è³‡æ–™ï¼ŒAPI æœƒå›å‚³ç‰©ä»¶è€Œä¸æ˜¯é™£åˆ—ï¼Œéœ€è½‰æ›
                        if (!Array.isArray(entries)) entries = [entries];
                        scores = entries;
                    }

                    if(scores.length === 0) {
                        list.innerHTML = '<li style="text-align:center;">ç›®å‰é‚„æ²’æœ‰äººä¸Šæ¦œï¼Œå¿«ä¾†ç•¶ç¬¬ä¸€åï¼</li>';
                        return;
                    }

                    scores.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.className = 'rank-item';
                        // æ¨™è¨˜è‡ªå·± (ç°¡å–®åˆ¤æ–·åå­—)
                        const myName = localStorage.getItem('xr_player_name');
                        if(entry.name === myName) li.style.background = '#f1f8e9';

                        li.innerHTML = `
                            <span style="width:30px;font-weight:bold;">#${index+1}</span>
                            <span>${entry.name}</span>
                            <span>${entry.score}</span>
                        `;
                        list.appendChild(li);
                    });
                })
                .catch(err => {
                    loading.innerText = "é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯";
                    console.error(err);
                });
        },
        checkNewRecord: function(score) {
            // åªæœ‰åœ°ç„æ¨¡å¼æ‰ä¸Šå‚³
            if(game.mode !== 'hard') return;
            if(!DreamloConfig.privateKey) return;

            // é¡¯ç¤ºè¼¸å…¥åå­—è¦–çª—
            this.tempScore = score;
            document.getElementById('name-overlay').style.display = 'flex';
            
            // é å¡«ä¸Šæ¬¡çš„åå­—
            const savedName = localStorage.getItem('xr_player_name');
            if(savedName) document.getElementById('player-name').value = savedName;
        },
        submit: function() {
            const nameInput = document.getElementById('player-name');
            const name = nameInput.value.trim() || "ç„¡åç„¡å°¾ç†Š";
            localStorage.setItem('xr_player_name', name); // è¨˜ä½åå­—

            const score = this.tempScore;
            const url = `https://www.dreamlo.com/lb/${DreamloConfig.privateKey}/add/${encodeURIComponent(name)}/${score}`;

            fetch(url)
                .then(() => {
                    alert('ä¸Šå‚³æˆåŠŸï¼');
                    document.getElementById('name-overlay').style.display = 'none';
                    this.show(); // é¡¯ç¤ºæ’è¡Œæ¦œ
                })
                .catch(err => alert('ä¸Šå‚³å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯'));
        }
    };

    /* 2. éŸ³æ•ˆç³»çµ± */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(400, 'sine', 0.1),
        drop: () => Sound.play(200, 'triangle', 0.1, 0.2),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(440*(1+i*0.5),'sine',0.3,0.2), i*50); },
        bomb: () => Sound.play(100, 'sawtooth', 0.8, 0.3)
    };

    /* 3. æ–¹å¡Šå®šç¾© */
    const SHAPES_EASY = [
        { m: [[1]], color: '#aed581' }, { m: [[1,1]], color: '#8bc34a' }, { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1,1]], color: '#689f38' }, { m: [[1],[1],[1]], color: '#689f38' }, { m: [[1,1],[1,1]], color: '#ffb74d' },
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' }, { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' },
        { m: [[1,1,1,1]], color: '#558b2f' }, { m: [[1],[1],[1],[1]], color: '#558b2f' }
    ];
    const SHAPES_HARD = [
        ...SHAPES_EASY,
        { m: [[1,1,1],[1,0,1]], color: '#ba68c8' }, { m: [[1,0,0],[1,1,1],[0,0,1]], color: '#7986cb' },
        { m: [[0,1,0],[1,1,1],[0,1,0]], color: '#4dd0e1' }, { m: [[1,1,1],[1,1,1],[1,1,1]], color: '#90a4ae' },
        { m: [[1,0,0,0,0],[1,1,1,1,1]], color: '#f06292' }
    ];

    /* 4. éŠæˆ²æ ¸å¿ƒ */
    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.mode = 'easy';
            this.particles = [];
            this.currentShape = null;
            this.ghostShape = null;
            this.TOUCH_OFFSET = 100;
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        start(mode) {
            this.mode = mode;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.updateScore(0);
            const savedBest = localStorage.getItem(`xr_puzzle_best_${mode}`) || 0;
            document.getElementById('best-score').innerText = savedBest;
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('final-score').style.display = 'none';
            this.spawnShapes();
            this.setKoalaEmotion('normal');
        }

        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            this.updateParticles();
            requestAnimationFrame(this.loop);
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }

        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save();
            this.ctx.globalAlpha = 0.4;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }

        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) {
                        this.drawCell(c, r, this.grid[r][c].color, 1, this.grid[r][c].bomb);
                    }
                }
            }
        }

        drawCell(x, y, color, scale=1, bombTimer=null) {
            const padding = 4;
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2;
            const cy = y * this.cellSize + this.cellSize/2;
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.scale(scale, scale);
            this.ctx.fillStyle = bombTimer !== null ? '#e53935' : color;
            this.ctx.beginPath();
            this.ctx.roundRect(-size/2, -size/2, size, size, 10);
            this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2);
            this.ctx.fill();
            if(bombTimer !== null) {
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 40px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(bombTimer, 0, 0);
                if(bombTimer <= 3) {
                    this.ctx.strokeStyle = `rgba(255,255,0,${Math.abs(Math.sin(Date.now()/100))})`;
                    this.ctx.lineWidth = 5;
                    this.ctx.strokeRect(-size/2, -size/2, size, size);
                }
            }
            this.ctx.restore();
        }

        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            const pool = this.mode === 'hard' ? SHAPES_HARD : SHAPES_EASY;
            for(let i=0; i<3; i++) {
                const shapeData = pool[Math.floor(Math.random() * pool.length)];
                let shapeWithBomb = JSON.parse(JSON.stringify(shapeData));
                if(this.mode === 'hard' && this.score > 300 && Math.random() < 0.3) {
                    shapeWithBomb.hasBomb = true;
                }
                this.createDraggableShape(shapeWithBomb, container);
            }
        }

        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 80; el.height = 80;
            el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length;
            const cols = data.m[0].length;
            const size = 12;
            const offsetX = (80 - cols*size)/2;
            const offsetY = (80 - rows*size)/2;
            ctx.fillStyle = data.hasBomb ? '#e53935' : data.color;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) {
                        ctx.beginPath();
                        ctx.roundRect(offsetX + c*size, offsetY + r*size, size-2, size-2, 3);
                        ctx.fill();
                    }
                }
            }
            const handleStart = (e) => {
                e.preventDefault(); Sound.pickup();
                el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };
            el.addEventListener('mousedown', handleStart);
            el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }

        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX;
                const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                el.style.left = (cx - 40) + 'px';
                el.style.top = (cy - 40 - this.TOUCH_OFFSET) + 'px';
                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                const shape = this.currentShape.data;
                const rows = shape.m.length;
                const cols = shape.m[0].length;
                const finalX = gx - Math.floor(cols/2);
                const finalY = gy - Math.floor(rows/2);
                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else {
                    this.ghostShape = null;
                }
            };
            const end = (ev) => {
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end);
                document.removeEventListener('touchend', end);
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize);
            const gy = Math.floor(y / this.cellSize);
            const shape = this.currentShape.data;
            const rows = shape.m.length;
            const cols = shape.m[0].length;
            const finalX = gx - Math.floor(cols/2);
            const finalY = gy - Math.floor(rows/2);
            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove();
                Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) setTimeout(() => this.spawnShapes(), 500);
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = '';
                this.currentShape.el.style.left = '';
                this.currentShape.el.style.top = '';
                this.currentShape.el.style.transform = '';
            }
            this.currentShape = null;
        }

        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c; const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) return false;
                    }
                }
            }
            return true;
        }

        place(shape, x, y) {
            let bombPlaced = false;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) {
                        let isBomb = false;
                        if(shape.hasBomb && !bombPlaced && Math.random() > 0.5) { isBomb = true; bombPlaced = true; }
                        if(shape.hasBomb && !bombPlaced && r==shape.m.length-1 && c==shape.m[0].length-1) isBomb = true;
                        this.grid[y+r][x+c] = { color: shape.color, bomb: isBomb ? 9 : null };
                    }
                }
            }
            let gameOver = false;
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0 && this.grid[r][c].bomb !== null) {
                        this.grid[r][c].bomb--;
                        if(this.grid[r][c].bomb < 0) gameOver = true;
                    }
                }
            }
            if(gameOver) { this.triggerGameOver("ç‚¸å½ˆçˆ†ç‚¸äº†ï¼ğŸ’¥"); return; }
            this.updateScore(10);
            this.checkLines();
        }

        checkLines() {
            let rowsToClear = []; let colsToClear = [];
            for(let r=0; r<this.gridSize; r++) if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            for(let c=0; c<this.gridSize; c++) {
                let full = true; for(let r=0; r<this.gridSize; r++) if(this.grid[r][c] === 0) full = false;
                if(full) colsToClear.push(c);
            }
            rowsToClear.forEach(r => { for(let c=0; c<this.gridSize; c++) { this.createParticles(c, r, this.grid[r][c].color); this.grid[r][c] = 0; } });
            colsToClear.forEach(c => { for(let r=0; r<this.gridSize; r++) { if(!rowsToClear.includes(r)) { this.createParticles(c, r, this.grid[r][c].color); this.grid[r][c] = 0; } } });
            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                Sound.clear(totalLines);
                let points = totalLines * 100 * totalLines; 
                this.updateScore(points);
                this.showFloatText(totalLines > 1 ? `COMBO x${totalLines}!` : "Nice!");
                this.setKoalaEmotion('happy');
                setTimeout(() => this.setKoalaEmotion('normal'), 2000);
            }
        }

        triggerGameOver(reason) {
            Sound.bomb();
            this.setKoalaEmotion('panic');
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-score').innerText = `æœ€çµ‚åˆ†æ•¸: ${this.score}\n(${reason || 'æ²’åœ°æ–¹æ”¾äº†'})`;
            document.getElementById('final-score').style.display = 'block';
            // æª¢æŸ¥æ˜¯å¦ç ´ç´€éŒ„ä¸¦ä¸Šå‚³
            Leaderboard.checkNewRecord(this.score);
        }

        updateScore(points) {
            this.score += points;
            document.getElementById('score').innerText = this.score;
            const key = `xr_puzzle_best_${this.mode}`;
            const currentBest = parseInt(localStorage.getItem(key) || 0);
            if(this.score > currentBest) {
                localStorage.setItem(key, this.score);
                document.getElementById('best-score').innerText = this.score;
            }
        }

        createParticles(gx, gy, color) {
            const cx = gx * this.cellSize + this.cellSize/2;
            const cy = gy * this.cellSize + this.cellSize/2;
            for(let i=0; i<5; i++) {
                this.particles.push({ x: cx, y: cy, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 1, color: color, size: Math.random() * 10 + 5 });
            }
        }

        updateParticles() {
            for(let i=this.particles.length-1; i>=0; i--) {
                let p = this.particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.05;
                if(p.life <= 0) { this.particles.splice(i, 1); } else { this.ctx.globalAlpha = p.life; this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); this.ctx.fill(); this.ctx.globalAlpha = 1; }
            }
        }

        showFloatText(text) {
            const el = document.createElement('div'); el.className = 'float-text'; el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%'; el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el); setTimeout(() => el.remove(), 1000);
        }

        setKoalaEmotion(state) {
            const k = document.getElementById('koala-mascot'); k.className = ''; k.classList.add(`koala-${state}`);
        }
    }

    const game = new BlockPuzzle();
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
