<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>瑄柔的無尾熊拼圖森林 · Koala Puzzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#558b2f">
    
    <!-- 引入圓潤字體與圖標 -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* =========================================
           1. 森林系配色 (Forest Palette)
        ========================================= */
        :root {
            --bg-color: #f1f8e9;      /* 背景淺綠 */
            --board-bg: #dcedc8;      /* 棋盤底色 */
            
            /* 方塊顏色 (牛油果色階) */
            --block-1: #aed581;       /* 淺綠 */
            --block-2: #8bc34a;       /* 中綠 */
            --block-3: #689f38;       /* 深綠 */
            --block-4: #ffb74d;       /* 點綴橘 (無尾熊色) */
            --block-5: #4db6ac;       /* 清新藍綠 */
            
            --text-main: #33691e;     /* 深綠文字 */
            --shadow: 0 8px 20px rgba(51, 105, 30, 0.15);
            --radius: 16px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden; /* 禁止捲動，專注遊戲 */
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--text-main);
        }

        /* =========================================
           2. 遊戲容器 (Game Container)
        ========================================= */
        #game-wrapper {
            position: relative; width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 20px;
        }

        /* 頂部資訊列 */
        header {
            width: 100%; display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; padding: 0 10px;
        }
        .score-box {
            background: white; padding: 10px 20px; border-radius: 30px;
            box-shadow: var(--shadow); display: flex; flex-direction: column; align-items: center;
            min-width: 100px;
        }
        .score-label { font-size: 0.8rem; color: #888; font-weight: bold; }
        .score-val { font-size: 1.5rem; font-weight: 900; color: var(--text-main); font-family: 'Fredoka'; }

        /* 無尾熊反應區 */
        #koala-mascot {
            width: 80px; height: 80px; position: relative;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #koala-mascot svg { width: 100%; height: 100%; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.1)); }
        
        /* 無尾熊表情動畫 */
        .koala-normal .mouth { d: path("M35 45 Q40 50 45 45"); }
        .koala-happy { transform: scale(1.2) rotate(-10deg); }
        .koala-happy .mouth { d: path("M35 45 Q40 55 45 45"); } /* 笑嘴 */
        .koala-sad { transform: translateY(5px); }
        .koala-sad .mouth { d: path("M35 50 Q40 45 45 50"); } /* 哭嘴 */

        /* =========================================
           3. 棋盤區域 (Canvas)
        ========================================= */
        #board-container {
            position: relative;
            width: 100%; aspect-ratio: 1/1; /* 正方形 */
            background: var(--board-bg);
            border-radius: var(--radius);
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.1), var(--shadow);
            padding: 10px;
            touch-action: none; /* 防止觸控捲動 */
        }
        canvas#game-canvas {
            width: 100%; height: 100%;
            border-radius: 8px;
            display: block;
        }

        /* =========================================
           4. 待選方塊區 (Spawn Area)
        ========================================= */
        #spawn-area {
            width: 100%; height: 140px;
            display: flex; justify-content: space-around; align-items: center;
            padding: 10px; margin-bottom: 20px;
        }
        .shape-preview {
            width: 80px; height: 80px;
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s;
        }
        /* 拖曳時的樣式 */
        .shape-preview.dragging {
            opacity: 0.8; z-index: 1000; position: fixed; pointer-events: none;
            transform: scale(1.2); /* 拖曳時放大 */
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.3));
        }

        /* =========================================
           5. 浮動文字特效 (Combo)
        ========================================= */
        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff8f00; font-size: 2rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 99;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* =========================================
           6. 遊戲結束/開始 遮罩
        ========================================= */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(85, 139, 47, 0.95); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        .overlay-card {
            background: white; padding: 40px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.2);
            max-width: 85%; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .btn-start {
            background: #8bc34a; color: white; border: none;
            padding: 15px 40px; font-size: 1.5rem; border-radius: 50px;
            margin-top: 20px; cursor: pointer; font-family: 'Zen Maru Gothic'; font-weight: bold;
            box-shadow: 0 5px 0 #558b2f; transition: 0.2s;
        }
        .btn-start:active { transform: translateY(5px); box-shadow: none; }

        /* 背景裝飾 */
        .bg-leaf {
            position: fixed; z-index: -1; opacity: 0.3;
            animation: floatBg 10s infinite ease-in-out;
        }
        @keyframes floatBg { 0%,100% { transform:translate(0,0) rotate(0deg); } 50% { transform:translate(20px, 20px) rotate(10deg); } }
    </style>
</head>
<body>

<!-- 背景裝飾 -->
<i class="fas fa-leaf bg-leaf" style="top:10%; left:10%; font-size: 50px; color: #aed581; animation-delay: 0s;"></i>
<i class="fas fa-leaf bg-leaf" style="top:80%; right:10%; font-size: 80px; color: #dcedc8; animation-delay: 2s;"></i>
<i class="fas fa-paw bg-leaf" style="top:20%; right:20%; font-size: 40px; color: #dcedc8; animation-delay: 4s;"></i>

<!-- 遊戲結束/開始遮罩 -->
<div id="overlay">
    <div class="overlay-card">
        <h1 style="color: #558b2f; margin-bottom: 10px;">無尾熊拼圖森林</h1>
        <p style="color: #666; margin-bottom: 20px;">瑄柔，準備好來場腦力激盪了嗎？</p>
        <div id="final-score" style="font-size: 2rem; font-weight: bold; color: #f57f17; display: none; margin-bottom: 20px;">0 分</div>
        <button class="btn-start" id="start-btn">開始遊戲</button>
    </div>
</div>

<div id="game-wrapper">
    
    <!-- 頂部資訊 -->
    <header>
        <div class="score-box">
            <span class="score-label">SCORE</span>
            <span class="score-val" id="score">0</span>
        </div>
        
        <!-- 無尾熊吉祥物 (SVG) -->
        <div id="koala-mascot" class="koala-normal">
            <svg viewBox="0 0 80 80">
                <circle cx="15" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="65" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="15" cy="25" r="8" fill="#f5f5f5"/>
                <circle cx="65" cy="25" r="8" fill="#f5f5f5"/>
                <ellipse cx="40" cy="40" rx="32" ry="28" fill="#9e9e9e"/>
                <circle cx="28" cy="35" r="3" fill="#333"/>
                <circle cx="52" cy="35" r="3" fill="#333"/>
                <ellipse cx="40" cy="42" rx="8" ry="10" fill="#424242"/>
                <path class="mouth" d="M35 55 Q40 60 45 55" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                <circle cx="20" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                <circle cx="60" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
            </svg>
        </div>

        <div class="score-box">
            <span class="score-label">BEST</span>
            <span class="score-val" id="best-score">0</span>
        </div>
    </header>

    <!-- 棋盤容器 -->
    <div id="board-container">
        <canvas id="game-canvas" width="800" height="800"></canvas>
    </div>

    <!-- 待選方塊區 -->
    <div id="spawn-area"></div>

</div>
<script>
    /* =========================================
       1. AUDIO SYNTHESIZER (音效合成)
    ========================================= */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const Sound = {
        playTone: (freq, type, duration, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        },
        pickup: () => Sound.playTone(400, 'sine', 0.1),
        drop: () => Sound.playTone(200, 'triangle', 0.1, 0.2),
        clear: (count) => {
            const base = 440;
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    Sound.playTone(base * (1 + i*0.5), 'sine', 0.3, 0.2);
                }, i * 50);
            }
        },
        gameover: () => {
            Sound.playTone(150, 'sawtooth', 0.5, 0.2);
        }
    };

    /* =========================================
       2. SHAPE DEFINITIONS (方塊形狀)
    ========================================= */
    const SHAPES = [
        { m: [[1]], color: '#aed581' },
        { m: [[1,1]], color: '#8bc34a' },
        { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1,1]], color: '#689f38' },
        { m: [[1],[1],[1]], color: '#689f38' },
        { m: [[1,1],[1,1]], color: '#ffb74d' },
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' },
        { m: [[0,1,0],[1,1,1]], color: '#4db6ac' },
        { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' },
        { m: [[1,1,1,1]], color: '#558b2f' },
        { m: [[1],[1],[1],[1]], color: '#558b2f' },
        { m: [[1,1,0],[0,1,1]], color: '#ba68c8' }
    ];

    /* =========================================
       3. GAME ENGINE CLASS (遊戲核心)
    ========================================= */
    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.bestScore = localStorage.getItem('xr_puzzle_best') || 0;
            this.particles = [];
            this.currentShape = null;
            this.ghostShape = null;
            
            // ★ 關鍵設定：手指偏移量 (像素)
            // 這會讓方塊浮在手指上方約 100px 的位置
            this.TOUCH_OFFSET = 100; 
            
            document.getElementById('best-score').innerText = this.bestScore;
            
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        start() {
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.updateScore(0);
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
            this.spawnShapes();
            this.setKoalaEmotion('normal');
            Sound.pickup();
        }

        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            this.updateParticles();
            requestAnimationFrame(this.loop);
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }

        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save();
            this.ctx.globalAlpha = 0.4;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) {
                        this.drawCell(x + c, y + r, shape.color); 
                    }
                }
            }
            this.ctx.restore();
        }

        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) {
                        this.drawCell(c, r, this.grid[r][c]);
                    }
                }
            }
        }

        drawCell(x, y, color, scale=1) {
            const padding = 4;
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2;
            const cy = y * this.cellSize + this.cellSize/2;
            
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.scale(scale, scale);
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.roundRect(-size/2, -size/2, size, size, 10);
            this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.restore();
        }

        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            for(let i=0; i<3; i++) {
                const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                this.createDraggableShape(shapeData, container);
            }
        }

        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 80; el.height = 80;
            el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length;
            const cols = data.m[0].length;
            const size = 15;
            const offsetX = (80 - cols*size)/2;
            const offsetY = (80 - rows*size)/2;
            
            ctx.fillStyle = data.color;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) {
                        ctx.beginPath();
                        ctx.roundRect(offsetX + c*size, offsetY + r*size, size-2, size-2, 4);
                        ctx.fill();
                    }
                }
            }

            const handleStart = (e) => {
                e.preventDefault();
                Sound.pickup();
                el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };

            el.addEventListener('mousedown', handleStart);
            el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }

        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX;
                const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                
                // ★ 視覺更新：方塊位置 = 手指位置 - 偏移量
                // 這樣方塊就會浮在手指上面，不會被擋住
                el.style.left = (cx - 40) + 'px';
                el.style.top = (cy - 40 - this.TOUCH_OFFSET) + 'px';

                // ★ 邏輯計算：落點判斷也要跟著往上移
                // 我們判斷的是「方塊看起來在哪裡」，而不是「手指在哪裡」
                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                // 這裡減去 TOUCH_OFFSET，讓落點判定與視覺位置一致
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                
                const shape = this.currentShape.data;
                const rows = shape.m.length;
                const cols = shape.m[0].length;
                const finalX = gx - Math.floor(cols/2);
                const finalY = gy - Math.floor(rows/2);

                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else {
                    this.ghostShape = null;
                }
            };

            const end = (ev) => {
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end);
                document.removeEventListener('touchend', end);
                
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };

            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            
            // ★ 放置判定：同樣要考慮偏移量
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            
            const gx = Math.floor(x / this.cellSize);
            const gy = Math.floor(y / this.cellSize);
            
            const shape = this.currentShape.data;
            const rows = shape.m.length;
            const cols = shape.m[0].length;
            const finalX = gx - Math.floor(cols/2);
            const finalY = gy - Math.floor(rows/2);

            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove();
                Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) {
                    setTimeout(() => this.spawnShapes(), 500);
                }
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = '';
                this.currentShape.el.style.left = '';
                this.currentShape.el.style.top = '';
                this.currentShape.el.style.transform = '';
            }
            this.currentShape = null;
        }

        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c;
                        const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        place(shape, x, y) {
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) {
                        this.grid[y+r][x+c] = shape.color;
                    }
                }
            }
            this.updateScore(10);
            this.checkLines();
        }

        checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for(let r=0; r<this.gridSize; r++) {
                if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            }
            for(let c=0; c<this.gridSize; c++) {
                let full = true;
                for(let r=0; r<this.gridSize; r++) {
                    if(this.grid[r][c] === 0) full = false;
                }
                if(full) colsToClear.push(c);
            }

            rowsToClear.forEach(r => {
                for(let c=0; c<this.gridSize; c++) {
                    this.createParticles(c, r, this.grid[r][c]);
                    this.grid[r][c] = 0;
                }
            });
            colsToClear.forEach(c => {
                for(let r=0; r<this.gridSize; r++) {
                    if(!rowsToClear.includes(r)) {
                        this.createParticles(c, r, this.grid[r][c]);
                        this.grid[r][c] = 0;
                    }
                }
            });

            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                Sound.clear(totalLines);
                let points = totalLines * 100 * totalLines; 
                this.updateScore(points);
                this.showFloatText(totalLines > 1 ? `COMBO x${totalLines}!` : "Nice!");
                this.setKoalaEmotion('happy');
                setTimeout(() => this.setKoalaEmotion('normal'), 2000);
            }
        }

        updateScore(points) {
            this.score += points;
            document.getElementById('score').innerText = this.score;
            if(this.score > this.bestScore) {
                this.bestScore = this.score;
                localStorage.setItem('xr_puzzle_best', this.bestScore);
                document.getElementById('best-score').innerText = this.bestScore;
            }
        }

        createParticles(gx, gy, color) {
            const cx = gx * this.cellSize + this.cellSize/2;
            const cy = gy * this.cellSize + this.cellSize/2;
            for(let i=0; i<5; i++) {
                this.particles.push({
                    x: cx, y: cy,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1, color: color, size: Math.random() * 10 + 5
                });
            }
        }

        updateParticles() {
            for(let i=this.particles.length-1; i>=0; i--) {
                let p = this.particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.05;
                if(p.life <= 0) {
                    this.particles.splice(i, 1);
                } else {
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                }
            }
        }

        showFloatText(text) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%';
            el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        setKoalaEmotion(state) {
            const k = document.getElementById('koala-mascot');
            k.className = '';
            k.classList.add(`koala-${state}`);
        }
    }

    // 初始化遊戲
    const game = new BlockPuzzle();
    
    // 綁定開始按鈕
    document.getElementById('start-btn').addEventListener('click', () => {
        game.start();
    });

    // 防止手機下拉刷新
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
