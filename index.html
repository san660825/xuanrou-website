<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ç„¡å°¾ç†Šæ‹¼åœ–ï¼šåœ°ç„æŒ‘æˆ°ç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#558b2f">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #f1f8e9;
            --board-bg: #dcedc8;
            --text-main: #33691e;
            --bomb-color: #e53935; /* ç‚¸å½ˆç´… */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--text-main);
        }

        #game-wrapper {
            position: relative; width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 20px;
        }

        header {
            width: 100%; display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; padding: 0 10px;
        }
        .score-box {
            background: white; padding: 8px 15px; border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center;
            min-width: 90px;
        }
        .score-label { font-size: 0.7rem; color: #888; font-weight: bold; }
        .score-val { font-size: 1.2rem; font-weight: 900; color: var(--text-main); font-family: 'Fredoka'; }

        #koala-mascot {
            width: 70px; height: 70px; transition: transform 0.3s;
        }
        .koala-panic { animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }

        #board-container {
            position: relative; width: 100%; aspect-ratio: 1/1;
            background: var(--board-bg); border-radius: 16px;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.1); padding: 10px;
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 8px; display: block; }

        #spawn-area {
            width: 100%; height: 140px; display: flex; justify-content: space-around; align-items: center;
        }
        .shape-preview {
            width: 80px; height: 80px; position: relative; transition: transform 0.1s;
        }
        .shape-preview.dragging {
            opacity: 0.9; z-index: 1000; position: fixed; pointer-events: none;
            transform: scale(1.1); filter: drop-shadow(0 20px 40px rgba(0,0,0,0.4));
        }

        /* æ’è¡Œæ¦œæŒ‰éˆ• */
        .rank-btn {
            position: absolute; top: 20px; right: 20px;
            background: #fbc02d; color: white; border: none; padding: 8px 15px;
            border-radius: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 #f57f17; z-index: 100;
        }
        .rank-btn:active { transform: translateY(4px); box-shadow: none; }

        /* é®ç½©èˆ‡å½ˆçª— */
        #overlay, #rank-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(85, 139, 47, 0.95); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s;
        }
        #rank-overlay { background: rgba(0,0,0,0.85); display: none; }
        
        .overlay-card {
            background: white; padding: 30px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            width: 85%; max-width: 400px;
        }
        
        .rank-list {
            list-style: none; text-align: left; margin: 20px 0; max-height: 300px; overflow-y: auto;
        }
        .rank-item {
            display: flex; justify-content: space-between; padding: 10px;
            border-bottom: 1px solid #eee; font-family: 'Fredoka';
        }
        .rank-item.me { background: #f1f8e9; color: #558b2f; font-weight: bold; border-radius: 10px; }
        .rank-num { width: 30px; font-weight: bold; color: #888; }

        .btn-start {
            background: #8bc34a; color: white; border: none;
            padding: 15px 40px; font-size: 1.5rem; border-radius: 50px;
            cursor: pointer; font-family: 'Zen Maru Gothic'; font-weight: bold;
            box-shadow: 0 5px 0 #558b2f;
        }
        .btn-close {
            background: #ccc; color: #555; border: none; padding: 10px 30px;
            border-radius: 20px; font-weight: bold; cursor: pointer; margin-top: 10px;
        }

        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff8f00; font-size: 2.5rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 99;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-30px) scale(1.2); opacity:1; } 100% { transform:translateY(-60px) scale(1); opacity:0; } }
    </style>
</head>
<body>

<!-- æ’è¡Œæ¦œæŒ‰éˆ• -->
<button class="rank-btn" onclick="showRank()">ğŸ† æ’è¡Œæ¦œ</button>

<!-- éŠæˆ²é–‹å§‹/çµæŸé®ç½© -->
<div id="overlay">
    <div class="overlay-card">
        <h1 style="color: #558b2f;">ç„¡å°¾ç†Šæ‹¼åœ–<br><span style="font-size:0.6em; color:#e53935;">ğŸ”¥ åœ°ç„æŒ‘æˆ°ç‰ˆ</span></h1>
        <p style="color: #666; margin: 15px 0;">å°å¿ƒï¼ç‚¸å½ˆæ–¹å¡Šå³å°‡å‡ºç¾ã€‚<br>å€’æ•¸æ­¸é›¶å‰å¿…é ˆæ¶ˆé™¤å®ƒï¼</p>
        <div id="final-score" style="font-size: 2rem; font-weight: bold; color: #f57f17; display: none; margin-bottom: 20px;">0</div>
        <button class="btn-start" id="start-btn">é–‹å§‹æŒ‘æˆ°</button>
    </div>
</div>

<!-- æ’è¡Œæ¦œé®ç½© -->
<div id="rank-overlay">
    <div class="overlay-card">
        <h2>ğŸ† å…¨çƒé«˜æ‰‹æ¦œ</h2>
        <ul class="rank-list" id="rank-list">
            <!-- JS ç”Ÿæˆ -->
        </ul>
        <button class="btn-close" onclick="closeRank()">é—œé–‰</button>
    </div>
</div>

<div id="game-wrapper">
    <header>
        <div class="score-box">
            <span class="score-label">SCORE</span>
            <span class="score-val" id="score">0</span>
        </div>
        
        <!-- ç„¡å°¾ç†Š SVG -->
        <div id="koala-mascot">
            <svg viewBox="0 0 80 80">
                <circle cx="15" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="65" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="15" cy="25" r="8" fill="#f5f5f5"/>
                <circle cx="65" cy="25" r="8" fill="#f5f5f5"/>
                <ellipse cx="40" cy="40" rx="32" ry="28" fill="#9e9e9e"/>
                <circle cx="28" cy="35" r="3" fill="#333"/>
                <circle cx="52" cy="35" r="3" fill="#333"/>
                <ellipse cx="40" cy="42" rx="8" ry="10" fill="#424242"/>
                <path class="mouth" d="M35 55 Q40 60 45 55" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                <circle cx="20" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                <circle cx="60" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
            </svg>
        </div>

        <div class="score-box">
            <span class="score-label">BEST</span>
            <span class="score-val" id="best-score">0</span>
        </div>
    </header>

    <div id="board-container">
        <canvas id="game-canvas" width="800" height="800"></canvas>
    </div>

    <div id="spawn-area"></div>
</div>

<script>
    /* =========================================
       1. AUDIO SYNTHESIZER
    ========================================= */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(400, 'sine', 0.1),
        drop: () => Sound.play(200, 'triangle', 0.1, 0.2),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(440*(1+i*0.5),'sine',0.3,0.2), i*50); },
        bomb: () => Sound.play(100, 'sawtooth', 0.8, 0.3), // ç‚¸å½ˆçˆ†ç‚¸è²
        tick: () => Sound.play(800, 'square', 0.05, 0.05)  // å€’æ•¸è²
    };

    /* =========================================
       2. EXPANDED SHAPES (æ›´å¤šè®Šæ…‹å½¢ç‹€)
    ========================================= */
    const SHAPES = [
        // åŸºç¤
        { m: [[1]], color: '#aed581' },
        { m: [[1,1]], color: '#8bc34a' },
        { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1],[1,1]], color: '#ffb74d' }, // ç”°
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' }, // T
        { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' }, // L
        { m: [[1,1,1,1]], color: '#558b2f' }, // 4é•·æ¢
        // é€²éš (é›£åº¦UP)
        { m: [[1,1,1],[1,0,1]], color: '#ba68c8' }, // Uå‹
        { m: [[1,0,0],[1,1,1],[0,0,1]], color: '#7986cb' }, // é–ƒé›»åŠ é•·
        { m: [[1,0,1],[1,1,1],[1,0,1]], color: '#e57373' }, // Hå‹
        { m: [[0,1,0],[1,1,1],[0,1,0]], color: '#4dd0e1' }, // åå­—
        { m: [[1,1,1],[1,1,1],[1,1,1]], color: '#90a4ae' }, // 3x3 å·¨å‹æ–¹å¡Š (æƒ¡å¤¢)
        { m: [[1,0,0,0,0],[1,1,1,1,1]], color: '#f06292' }, // 5æ ¼L
        { m: [[1],[1],[1],[1],[1]], color: '#558b2f' } // 5æ ¼é•·æ¢
    ];

    /* =========================================
       3. FAKE GLOBAL RANKING
    ========================================= */
    const FAKE_PLAYERS = [
        {name: "KoalaMaster", score: 12500},
        {name: "ForestKing", score: 9800},
        {name: "Eucalyptus", score: 8540},
        {name: "LazyBear", score: 7200},
        {name: "BambooLover", score: 5600},
        {name: "SleepyHead", score: 4300},
        {name: "GreenLeaf", score: 3100}
    ];

    function showRank() {
        const list = document.getElementById('rank-list');
        list.innerHTML = '';
        
        // æ’å…¥ç©å®¶ç•¶å‰åˆ†æ•¸
        const myScore = parseInt(document.getElementById('score').innerText);
        let allPlayers = [...FAKE_PLAYERS, {name: "ç‘„æŸ” (å¦³)", score: myScore, isMe: true}];
        
        // æ’åº
        allPlayers.sort((a,b) => b.score - a.score);
        
        allPlayers.forEach((p, i) => {
            const li = document.createElement('li');
            li.className = `rank-item ${p.isMe ? 'me' : ''}`;
            li.innerHTML = `<span class="rank-num">#${i+1}</span><span>${p.name}</span><span>${p.score}</span>`;
            list.appendChild(li);
        });
        
        document.getElementById('rank-overlay').style.display = 'flex';
    }
    function closeRank() { document.getElementById('rank-overlay').style.display = 'none'; }

    /* =========================================
       4. GAME ENGINE
    ========================================= */
    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            // Grid now stores objects: { color: string, bomb: number|null } or 0
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            
            this.score = 0;
            this.bestScore = localStorage.getItem('xr_puzzle_best') || 0;
            this.particles = [];
            this.currentShape = null;
            this.ghostShape = null;
            this.TOUCH_OFFSET = 100; // æ‰‹æ©Ÿæ‰‹æŒ‡åç§»é‡
            this.bombsActive = false; // åˆ†æ•¸é«˜æ–¼ 500 é–‹å•Ÿç‚¸å½ˆ

            document.getElementById('best-score').innerText = this.bestScore;
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        start() {
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.bombsActive = false;
            this.updateScore(0);
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('final-score').style.display = 'none';
            this.spawnShapes();
            this.setKoalaEmotion('normal');
        }

        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            this.updateParticles();
            requestAnimationFrame(this.loop);
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }

        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save();
            this.ctx.globalAlpha = 0.4;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }

        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) {
                        // ç¹ªè£½æ–¹å¡Šèˆ‡ç‚¸å½ˆ
                        this.drawCell(c, r, this.grid[r][c].color, 1, this.grid[r][c].bomb);
                    }
                }
            }
        }

        drawCell(x, y, color, scale=1, bombTimer=null) {
            const padding = 4;
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2;
            const cy = y * this.cellSize + this.cellSize/2;
            
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.scale(scale, scale);
            
            // ç‚¸å½ˆæ–¹å¡Šè®Šç´…è‰²
            this.ctx.fillStyle = bombTimer !== null ? '#e53935' : color;
            
            this.ctx.beginPath();
            this.ctx.roundRect(-size/2, -size/2, size, size, 10);
            this.ctx.fill();
            
            // é«˜å…‰
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2);
            this.ctx.fill();

            // ç¹ªè£½ç‚¸å½ˆæ•¸å­—
            if(bombTimer !== null) {
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 40px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(bombTimer, 0, 0);
                
                // ç‚¸å½ˆå¤–åœˆé–ƒçˆ
                if(bombTimer <= 3) {
                    this.ctx.strokeStyle = `rgba(255,255,0,${Math.abs(Math.sin(Date.now()/100))})`;
                    this.ctx.lineWidth = 5;
                    this.ctx.strokeRect(-size/2, -size/2, size, size);
                }
            }

            this.ctx.restore();
        }

        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            for(let i=0; i<3; i++) {
                const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                // éš¨æ©Ÿè³¦äºˆç‚¸å½ˆå±¬æ€§ (å¦‚æœåˆ†æ•¸å¤ é«˜)
                let shapeWithBomb = JSON.parse(JSON.stringify(shapeData));
                if(this.score > 500 && Math.random() < 0.3) {
                    shapeWithBomb.hasBomb = true;
                }
                this.createDraggableShape(shapeWithBomb, container);
            }
        }

        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 80; el.height = 80;
            el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length;
            const cols = data.m[0].length;
            const size = 12; // é è¦½ç¨å¾®ç¸®å°ä»¥é©æ‡‰è¤‡é›œå½¢ç‹€
            const offsetX = (80 - cols*size)/2;
            const offsetY = (80 - rows*size)/2;
            
            ctx.fillStyle = data.hasBomb ? '#e53935' : data.color;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) {
                        ctx.beginPath();
                        ctx.roundRect(offsetX + c*size, offsetY + r*size, size-2, size-2, 3);
                        ctx.fill();
                    }
                }
            }

            const handleStart = (e) => {
                e.preventDefault();
                Sound.pickup();
                el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };

            el.addEventListener('mousedown', handleStart);
            el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }

        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX;
                const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                
                el.style.left = (cx - 40) + 'px';
                el.style.top = (cy - 40 - this.TOUCH_OFFSET) + 'px';

                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                
                const shape = this.currentShape.data;
                const rows = shape.m.length;
                const cols = shape.m[0].length;
                const finalX = gx - Math.floor(cols/2);
                const finalY = gy - Math.floor(rows/2);

                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else {
                    this.ghostShape = null;
                }
            };

            const end = (ev) => {
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end);
                document.removeEventListener('touchend', end);
                
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };

            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize);
            const gy = Math.floor(y / this.cellSize);
            
            const shape = this.currentShape.data;
            const rows = shape.m.length;
            const cols = shape.m[0].length;
            const finalX = gx - Math.floor(cols/2);
            const finalY = gy - Math.floor(rows/2);

            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove();
                Sound.drop();
                
                // æª¢æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ–°æ–¹å¡Š
                if(document.getElementById('spawn-area').children.length === 0) {
                    setTimeout(() => this.spawnShapes(), 500);
                }
                
                // æª¢æŸ¥æ˜¯å¦éŠæˆ²çµæŸ (æ²’åœ°æ–¹æ”¾)
                // é€™è£¡ç°¡åŒ–è™•ç†ï¼šå¦‚æœç‚¸å½ˆçˆ†ç‚¸æœƒè§¸ç™¼ GameOver
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = '';
                this.currentShape.el.style.left = '';
                this.currentShape.el.style.top = '';
                this.currentShape.el.style.transform = '';
            }
            this.currentShape = null;
        }

        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c;
                        const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        place(shape, x, y) {
            // 1. æ”¾ç½®æ–°æ–¹å¡Š
            let bombPlaced = false;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) {
                        // å¦‚æœé€™å€‹å½¢ç‹€å¸¶æœ‰ç‚¸å½ˆï¼Œéš¨æ©Ÿé¸ä¸€å€‹æ ¼å­è®Šæˆç‚¸å½ˆ
                        let isBomb = false;
                        if(shape.hasBomb && !bombPlaced && Math.random() > 0.5) {
                            isBomb = true;
                            bombPlaced = true;
                        }
                        // ç¢ºä¿è‡³å°‘æœ‰ä¸€å€‹ç‚¸å½ˆå¦‚æœ flag æ˜¯ true
                        if(shape.hasBomb && !bombPlaced && r==shape.m.length-1 && c==shape.m[0].length-1) {
                            isBomb = true;
                        }

                        this.grid[y+r][x+c] = {
                            color: shape.color,
                            bomb: isBomb ? 9 : null // ç‚¸å½ˆå€’æ•¸ 9 å›åˆ
                        };
                    }
                }
            }

            // 2. æ›´æ–°æ‰€æœ‰ç¾å­˜ç‚¸å½ˆçš„å€’æ•¸
            let gameOver = false;
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0 && this.grid[r][c].bomb !== null) {
                        this.grid[r][c].bomb--;
                        if(this.grid[r][c].bomb < 0) gameOver = true;
                    }
                }
            }

            if(gameOver) {
                this.triggerGameOver("ç‚¸å½ˆçˆ†ç‚¸äº†ï¼ğŸ’¥");
                return;
            }

            this.updateScore(10);
            this.checkLines();
        }

        checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for(let r=0; r<this.gridSize; r++) {
                if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            }
            for(let c=0; c<this.gridSize; c++) {
                let full = true;
                for(let r=0; r<this.gridSize; r++) {
                    if(this.grid[r][c] === 0) full = false;
                }
                if(full) colsToClear.push(c);
            }

            // åŸ·è¡Œæ¶ˆé™¤
            rowsToClear.forEach(r => {
                for(let c=0; c<this.gridSize; c++) {
                    this.createParticles(c, r, this.grid[r][c].color);
                    this.grid[r][c] = 0;
                }
            });
            colsToClear.forEach(c => {
                for(let r=0; r<this.gridSize; r++) {
                    if(!rowsToClear.includes(r)) {
                        this.createParticles(c, r, this.grid[r][c].color);
                        this.grid[r][c] = 0;
                    }
                }
            });

            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                Sound.clear(totalLines);
                let points = totalLines * 100 * totalLines; 
                this.updateScore(points);
                this.showFloatText(totalLines > 1 ? `COMBO x${totalLines}!` : "Nice!");
                this.setKoalaEmotion('happy');
                setTimeout(() => this.setKoalaEmotion('normal'), 2000);
            }
        }

        triggerGameOver(reason) {
            Sound.bomb();
            this.setKoalaEmotion('panic');
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-score').innerText = `æœ€çµ‚åˆ†æ•¸: ${this.score}\n(${reason})`;
            document.getElementById('final-score').style.display = 'block';
            document.getElementById('start-btn').innerText = "å†æŒ‘æˆ°ä¸€æ¬¡";
        }

        updateScore(points) {
            this.score += points;
            document.getElementById('score').innerText = this.score;
            if(this.score > this.bestScore) {
                this.bestScore = this.score;
                localStorage.setItem('xr_puzzle_best', this.bestScore);
                document.getElementById('best-score').innerText = this.bestScore;
            }
        }

        createParticles(gx, gy, color) {
            const cx = gx * this.cellSize + this.cellSize/2;
            const cy = gy * this.cellSize + this.cellSize/2;
            for(let i=0; i<5; i++) {
                this.particles.push({
                    x: cx, y: cy,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1, color: color, size: Math.random() * 10 + 5
                });
            }
        }

        updateParticles() {
            for(let i=this.particles.length-1; i>=0; i--) {
                let p = this.particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.05;
                if(p.life <= 0) {
                    this.particles.splice(i, 1);
                } else {
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                }
            }
        }

        showFloatText(text) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%';
            el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        setKoalaEmotion(state) {
            const k = document.getElementById('koala-mascot');
            k.className = '';
            k.classList.add(`koala-${state}`);
        }
    }

    const game = new BlockPuzzle();
    document.getElementById('start-btn').addEventListener('click', () => game.start());
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
