<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>ÁÑ°Â∞æÁÜäÊãºÂúñÔºöÈõôÈáçÊ®°ÂºèÁâà</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#558b2f">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #f1f8e9;
            --board-bg: #dcedc8;
            --text-main: #33691e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--text-main);
        }

        #game-wrapper {
            position: relative; width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 20px;
        }

        header {
            width: 100%; display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; padding: 0 10px;
        }
        .score-box {
            background: white; padding: 8px 15px; border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center;
            min-width: 90px;
        }
        .score-label { font-size: 0.7rem; color: #888; font-weight: bold; }
        .score-val { font-size: 1.2rem; font-weight: 900; color: var(--text-main); font-family: 'Fredoka'; }

        #koala-mascot {
            width: 70px; height: 70px; transition: transform 0.3s;
        }
        .koala-panic { animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, -1px); } }

        #board-container {
            position: relative; width: 100%; aspect-ratio: 1/1;
            background: var(--board-bg); border-radius: 16px;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.1); padding: 10px;
        }
        canvas#game-canvas { width: 100%; height: 100%; border-radius: 8px; display: block; }

        #spawn-area {
            width: 100%; height: 140px; display: flex; justify-content: space-around; align-items: center;
        }
        .shape-preview {
            width: 80px; height: 80px; position: relative; transition: transform 0.1s;
        }
        .shape-preview.dragging {
            opacity: 0.9; z-index: 1000; position: fixed; pointer-events: none;
            transform: scale(1.1); filter: drop-shadow(0 30px 50px rgba(0,0,0,0.3));
        }

        /* ÊåâÈàïÊ®£Âºè */
        .rank-btn {
            position: absolute; top: 20px; right: 20px;
            background: #fbc02d; color: white; border: none; padding: 8px 15px;
            border-radius: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 #f57f17; z-index: 100;
        }
        
        #overlay, #rank-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(85, 139, 47, 0.95); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s;
        }
        #rank-overlay { background: rgba(0,0,0,0.85); display: none; }
        
        .overlay-card {
            background: white; padding: 30px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            width: 85%; max-width: 400px;
        }

        .mode-select {
            display: flex; flex-direction: column; gap: 15px; margin-top: 20px;
        }
        .btn-mode {
            border: none; padding: 15px; font-size: 1.2rem; border-radius: 50px;
            cursor: pointer; font-family: 'Zen Maru Gothic'; font-weight: bold;
            transition: 0.2s; color: white; position: relative; overflow: hidden;
        }
        .btn-easy { background: #8bc34a; box-shadow: 0 5px 0 #558b2f; }
        .btn-hard { background: #e53935; box-shadow: 0 5px 0 #b71c1c; }
        .btn-mode:active { transform: translateY(5px); box-shadow: none; }
        
        .rank-list { list-style: none; text-align: left; margin: 20px 0; max-height: 300px; overflow-y: auto; }
        .rank-item { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #eee; }
        .rank-item.me { background: #f1f8e9; color: #558b2f; font-weight: bold; border-radius: 10px; }
        .btn-close { background: #ccc; color: #555; border: none; padding: 10px 30px; border-radius: 20px; margin-top: 10px; }

        .float-text {
            position: absolute; font-family: 'Fredoka'; font-weight: 900;
            color: #ff8f00; font-size: 2.5rem; pointer-events: none;
            text-shadow: 2px 2px 0px white; z-index: 99;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp { 0% { transform:translateY(0) scale(0.5); opacity:0; } 50% { transform:translateY(-30px) scale(1.2); opacity:1; } 100% { transform:translateY(-60px) scale(1); opacity:0; } }
    </style>
</head>
<body>

<button class="rank-btn" onclick="showRank()">üèÜ ÊéíË°åÊ¶ú</button>

<!-- ÈÅäÊà≤ÈñãÂßã/Ê®°ÂºèÈÅ∏ÊìáÈÅÆÁΩ© -->
<div id="overlay">
    <div class="overlay-card">
        <h1 style="color: #558b2f; margin-bottom: 5px;">ÁÑ°Â∞æÁÜäÊãºÂúñ</h1>
        <p style="color: #888; font-size: 0.9rem;">ÁëÑÊüîÔºå‰ªäÂ§©ÊÉ≥Áé©Âì™‰∏ÄÁ®ÆÔºü</p>
        
        <div id="final-score" style="font-size: 1.5rem; font-weight: bold; color: #f57f17; display: none; margin: 15px 0;">
            0 ÂàÜ
        </div>

        <div class="mode-select">
            <button class="btn-mode btn-easy" onclick="game.start('easy')">
                <i class="fas fa-coffee"></i> ËºïÈ¨ÜÊ®°Âºè
                <div style="font-size: 0.7rem; opacity: 0.8;">ÁÑ°ÁÇ∏ÂΩà ¬∑ Á¥îÊîæÈ¨Ü</div>
            </button>
            <button class="btn-mode btn-hard" onclick="game.start('hard')">
                <i class="fas fa-fire"></i> Âú∞ÁçÑÊ®°Âºè
                <div style="font-size: 0.7rem; opacity: 0.8;">ÁÇ∏ÂΩàÂÄíÊï∏ ¬∑ ËÆäÊÖãÊñπÂ°ä</div>
            </button>
        </div>
    </div>
</div>

<!-- ÊéíË°åÊ¶úÈÅÆÁΩ© -->
<div id="rank-overlay">
    <div class="overlay-card">
        <h2>üèÜ ÂÖ®ÁêÉÈ´òÊâãÊ¶ú</h2>
        <div style="font-size:0.8rem; color:#888; margin-bottom:10px;">(È°ØÁ§∫Âú∞ÁçÑÊ®°ÂºèÂàÜÊï∏)</div>
        <ul class="rank-list" id="rank-list"></ul>
        <button class="btn-close" onclick="closeRank()">ÈóúÈñâ</button>
    </div>
</div>

<div id="game-wrapper">
    <header>
        <div class="score-box">
            <span class="score-label">SCORE</span>
            <span class="score-val" id="score">0</span>
        </div>
        <div id="koala-mascot">
            <svg viewBox="0 0 80 80">
                <circle cx="15" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="65" cy="25" r="12" fill="#9e9e9e"/>
                <circle cx="15" cy="25" r="8" fill="#f5f5f5"/>
                <circle cx="65" cy="25" r="8" fill="#f5f5f5"/>
                <ellipse cx="40" cy="40" rx="32" ry="28" fill="#9e9e9e"/>
                <circle cx="28" cy="35" r="3" fill="#333"/>
                <circle cx="52" cy="35" r="3" fill="#333"/>
                <ellipse cx="40" cy="42" rx="8" ry="10" fill="#424242"/>
                <path class="mouth" d="M35 55 Q40 60 45 55" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                <circle cx="20" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
                <circle cx="60" cy="45" r="4" fill="rgba(255,100,100,0.3)"/>
            </svg>
        </div>
        <div class="score-box">
            <span class="score-label">BEST</span>
            <span class="score-val" id="best-score">0</span>
        </div>
    </header>

    <div id="board-container">
        <canvas id="game-canvas" width="800" height="800"></canvas>
    </div>
    <div id="spawn-area"></div>
</div>

<script>
    /* 1. Èü≥ÊïàÁ≥ªÁµ± */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        },
        pickup: () => Sound.play(400, 'sine', 0.1),
        drop: () => Sound.play(200, 'triangle', 0.1, 0.2),
        clear: (n) => { for(let i=0;i<n;i++) setTimeout(()=>Sound.play(440*(1+i*0.5),'sine',0.3,0.2), i*50); },
        bomb: () => Sound.play(100, 'sawtooth', 0.8, 0.3)
    };

    /* 2. ÊñπÂ°äÂÆöÁæ© (ÂàÜÁ∞°ÂñÆËàáÂõ∞Èõ£) */
    const SHAPES_EASY = [
        { m: [[1]], color: '#aed581' },
        { m: [[1,1]], color: '#8bc34a' },
        { m: [[1],[1]], color: '#8bc34a' },
        { m: [[1,1,1]], color: '#689f38' },
        { m: [[1],[1],[1]], color: '#689f38' },
        { m: [[1,1],[1,1]], color: '#ffb74d' },
        { m: [[1,1,1],[0,1,0]], color: '#4db6ac' },
        { m: [[1,0],[1,0],[1,1]], color: '#ff8a65' },
        { m: [[1,1,1,1]], color: '#558b2f' },
        { m: [[1],[1],[1],[1]], color: '#558b2f' }
    ];

    const SHAPES_HARD = [
        ...SHAPES_EASY, // ÂåÖÂê´Âü∫Á§éÊñπÂ°ä
        { m: [[1,1,1],[1,0,1]], color: '#ba68c8' }, // UÂûã
        { m: [[1,0,0],[1,1,1],[0,0,1]], color: '#7986cb' }, // ÈñÉÈõªÂä†Èï∑
        { m: [[0,1,0],[1,1,1],[0,1,0]], color: '#4dd0e1' }, // ÂçÅÂ≠ó
        { m: [[1,1,1],[1,1,1],[1,1,1]], color: '#90a4ae' }, // 3x3
        { m: [[1,0,0,0,0],[1,1,1,1,1]], color: '#f06292' }  // 5Ê†ºL
    ];

    /* 3. ÂÅáÊéíÂêçË≥áÊñô */
    const FAKE_PLAYERS = [
        {name: "KoalaKing", score: 15200}, {name: "ForestMaster", score: 12800},
        {name: "Eucalyptus", score: 9540}, {name: "LazyBear", score: 7200},
        {name: "Bamboo", score: 5600}
    ];

    function showRank() {
        const list = document.getElementById('rank-list');
        list.innerHTML = '';
        // ÊäìÂèñÂú∞ÁçÑÊ®°ÂºèÊúÄÈ´òÂàÜ‰æÜÊéíÂêç
        const myBest = localStorage.getItem('xr_puzzle_best_hard') || 0;
        let allPlayers = [...FAKE_PLAYERS, {name: "ÁëÑÊüî (Â¶≥)", score: parseInt(myBest), isMe: true}];
        allPlayers.sort((a,b) => b.score - a.score);
        
        allPlayers.forEach((p, i) => {
            const li = document.createElement('li');
            li.className = `rank-item ${p.isMe ? 'me' : ''}`;
            li.innerHTML = `<span style="width:30px;font-weight:bold;">#${i+1}</span><span>${p.name}</span><span>${p.score}</span>`;
            list.appendChild(li);
        });
        document.getElementById('rank-overlay').style.display = 'flex';
    }
    function closeRank() { document.getElementById('rank-overlay').style.display = 'none'; }

    /* 4. ÈÅäÊà≤Ê†∏ÂøÉ */
    class BlockPuzzle {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.gridSize = 8;
            this.cellSize = this.canvas.width / this.gridSize;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            
            this.score = 0;
            this.mode = 'easy'; // Áï∂ÂâçÊ®°Âºè
            this.particles = [];
            this.currentShape = null;
            this.ghostShape = null;
            this.TOUCH_OFFSET = 100; // ÊâãÊåáÂÅèÁßª

            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        start(mode) {
            this.mode = mode;
            this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
            this.score = 0;
            this.updateScore(0);
            
            // ËÆÄÂèñË©≤Ê®°ÂºèÁöÑÊúÄÈ´òÂàÜ
            const savedBest = localStorage.getItem(`xr_puzzle_best_${mode}`) || 0;
            document.getElementById('best-score').innerText = savedBest;

            document.getElementById('overlay').style.display = 'none';
            document.getElementById('final-score').style.display = 'none';
            this.spawnShapes();
            this.setKoalaEmotion('normal');
        }

        loop() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            if (this.ghostShape) this.drawGhost();
            this.drawPlacedBlocks();
            this.updateParticles();
            requestAnimationFrame(this.loop);
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            this.ctx.lineWidth = 2;
            for(let i=0; i<=this.gridSize; i++) {
                let pos = i * this.cellSize;
                this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(800, pos); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, 800); this.ctx.stroke();
            }
        }

        drawGhost() {
            const { x, y, shape } = this.ghostShape;
            this.ctx.save();
            this.ctx.globalAlpha = 0.4;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) this.drawCell(x + c, y + r, shape.color); 
                }
            }
            this.ctx.restore();
        }

        drawPlacedBlocks() {
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0) {
                        this.drawCell(c, r, this.grid[r][c].color, 1, this.grid[r][c].bomb);
                    }
                }
            }
        }

        drawCell(x, y, color, scale=1, bombTimer=null) {
            const padding = 4;
            const size = this.cellSize - padding * 2;
            const cx = x * this.cellSize + this.cellSize/2;
            const cy = y * this.cellSize + this.cellSize/2;
            
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.scale(scale, scale);
            this.ctx.fillStyle = bombTimer !== null ? '#e53935' : color;
            this.ctx.beginPath();
            this.ctx.roundRect(-size/2, -size/2, size, size, 10);
            this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.arc(-size/4, -size/4, size/6, 0, Math.PI*2);
            this.ctx.fill();

            if(bombTimer !== null) {
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 40px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(bombTimer, 0, 0);
                if(bombTimer <= 3) {
                    this.ctx.strokeStyle = `rgba(255,255,0,${Math.abs(Math.sin(Date.now()/100))})`;
                    this.ctx.lineWidth = 5;
                    this.ctx.strokeRect(-size/2, -size/2, size, size);
                }
            }
            this.ctx.restore();
        }

        spawnShapes() {
            const container = document.getElementById('spawn-area');
            container.innerHTML = '';
            // Ê†πÊìöÊ®°ÂºèÈÅ∏ÊìáÂΩ¢ÁãÄÂ∫´
            const pool = this.mode === 'hard' ? SHAPES_HARD : SHAPES_EASY;

            for(let i=0; i<3; i++) {
                const shapeData = pool[Math.floor(Math.random() * pool.length)];
                let shapeWithBomb = JSON.parse(JSON.stringify(shapeData));
                
                // Âè™ÊúâÂú∞ÁçÑÊ®°Âºè‰∏îÂàÜÊï∏>300ÊâçÊúÉÊúâÁÇ∏ÂΩà
                if(this.mode === 'hard' && this.score > 300 && Math.random() < 0.3) {
                    shapeWithBomb.hasBomb = true;
                }
                this.createDraggableShape(shapeWithBomb, container);
            }
        }

        createDraggableShape(data, container) {
            const el = document.createElement('canvas');
            el.width = 80; el.height = 80;
            el.className = 'shape-preview';
            const ctx = el.getContext('2d');
            const rows = data.m.length;
            const cols = data.m[0].length;
            const size = 12;
            const offsetX = (80 - cols*size)/2;
            const offsetY = (80 - rows*size)/2;
            
            ctx.fillStyle = data.hasBomb ? '#e53935' : data.color;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.m[r][c]) {
                        ctx.beginPath();
                        ctx.roundRect(offsetX + c*size, offsetY + r*size, size-2, size-2, 3);
                        ctx.fill();
                    }
                }
            }

            const handleStart = (e) => {
                e.preventDefault();
                Sound.pickup();
                el.classList.add('dragging');
                this.currentShape = { el, data, startX: e.clientX || e.touches[0].clientX, startY: e.clientY || e.touches[0].clientY };
                this.moveShape(e);
            };

            el.addEventListener('mousedown', handleStart);
            el.addEventListener('touchstart', handleStart);
            container.appendChild(el);
        }

        moveShape(e) {
            const move = (ev) => {
                if(!this.currentShape) return;
                const cx = ev.clientX || ev.touches[0].clientX;
                const cy = ev.clientY || ev.touches[0].clientY;
                const el = this.currentShape.el;
                
                el.style.left = (cx - 40) + 'px';
                el.style.top = (cy - 40 - this.TOUCH_OFFSET) + 'px';

                const rect = this.canvas.getBoundingClientRect();
                const x = (cx - rect.left) * (this.canvas.width / rect.width);
                const y = (cy - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
                
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                
                const shape = this.currentShape.data;
                const rows = shape.m.length;
                const cols = shape.m[0].length;
                const finalX = gx - Math.floor(cols/2);
                const finalY = gy - Math.floor(rows/2);

                if(this.canPlace(shape.m, finalX, finalY)) {
                    this.ghostShape = { x: finalX, y: finalY, shape: shape };
                } else {
                    this.ghostShape = null;
                }
            };

            const end = (ev) => {
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mouseup', end);
                document.removeEventListener('touchend', end);
                
                if(!this.currentShape) return;
                const cx = ev.clientX || (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
                const cy = ev.clientY || (ev.changedTouches ? ev.changedTouches[0].clientY : 0);
                this.tryPlaceShape(cx, cy);
            };

            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        tryPlaceShape(mx, my) {
            this.ghostShape = null;
            const rect = this.canvas.getBoundingClientRect();
            const x = (mx - rect.left) * (this.canvas.width / rect.width);
            const y = (my - this.TOUCH_OFFSET - rect.top) * (this.canvas.height / rect.height);
            const gx = Math.floor(x / this.cellSize);
            const gy = Math.floor(y / this.cellSize);
            
            const shape = this.currentShape.data;
            const rows = shape.m.length;
            const cols = shape.m[0].length;
            const finalX = gx - Math.floor(cols/2);
            const finalY = gy - Math.floor(rows/2);

            if(this.canPlace(shape.m, finalX, finalY)) {
                this.place(shape, finalX, finalY);
                this.currentShape.el.remove();
                Sound.drop();
                if(document.getElementById('spawn-area').children.length === 0) {
                    setTimeout(() => this.spawnShapes(), 500);
                }
            } else {
                this.currentShape.el.classList.remove('dragging');
                this.currentShape.el.style.position = '';
                this.currentShape.el.style.left = '';
                this.currentShape.el.style.top = '';
                this.currentShape.el.style.transform = '';
            }
            this.currentShape = null;
        }

        canPlace(matrix, x, y) {
            for(let r=0; r<matrix.length; r++) {
                for(let c=0; c<matrix[0].length; c++) {
                    if(matrix[r][c]) {
                        const nx = x + c;
                        const ny = y + r;
                        if(nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize || this.grid[ny][nx] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        place(shape, x, y) {
            let bombPlaced = false;
            for(let r=0; r<shape.m.length; r++) {
                for(let c=0; c<shape.m[0].length; c++) {
                    if(shape.m[r][c]) {
                        let isBomb = false;
                        if(shape.hasBomb && !bombPlaced && Math.random() > 0.5) {
                            isBomb = true; bombPlaced = true;
                        }
                        if(shape.hasBomb && !bombPlaced && r==shape.m.length-1 && c==shape.m[0].length-1) {
                            isBomb = true;
                        }
                        this.grid[y+r][x+c] = { color: shape.color, bomb: isBomb ? 9 : null };
                    }
                }
            }

            // ÁÇ∏ÂΩàÂÄíÊï∏
            let gameOver = false;
            for(let r=0; r<this.gridSize; r++) {
                for(let c=0; c<this.gridSize; c++) {
                    if(this.grid[r][c] !== 0 && this.grid[r][c].bomb !== null) {
                        this.grid[r][c].bomb--;
                        if(this.grid[r][c].bomb < 0) gameOver = true;
                    }
                }
            }

            if(gameOver) {
                this.triggerGameOver("ÁÇ∏ÂΩàÁàÜÁÇ∏‰∫ÜÔºÅüí•");
                return;
            }

            this.updateScore(10);
            this.checkLines();
        }

        checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for(let r=0; r<this.gridSize; r++) {
                if(this.grid[r].every(cell => cell !== 0)) rowsToClear.push(r);
            }
            for(let c=0; c<this.gridSize; c++) {
                let full = true;
                for(let r=0; r<this.gridSize; r++) {
                    if(this.grid[r][c] === 0) full = false;
                }
                if(full) colsToClear.push(c);
            }

            rowsToClear.forEach(r => {
                for(let c=0; c<this.gridSize; c++) {
                    this.createParticles(c, r, this.grid[r][c].color);
                    this.grid[r][c] = 0;
                }
            });
            colsToClear.forEach(c => {
                for(let r=0; r<this.gridSize; r++) {
                    if(!rowsToClear.includes(r)) {
                        this.createParticles(c, r, this.grid[r][c].color);
                        this.grid[r][c] = 0;
                    }
                }
            });

            const totalLines = rowsToClear.length + colsToClear.length;
            if(totalLines > 0) {
                Sound.clear(totalLines);
                let points = totalLines * 100 * totalLines; 
                this.updateScore(points);
                this.showFloatText(totalLines > 1 ? `COMBO x${totalLines}!` : "Nice!");
                this.setKoalaEmotion('happy');
                setTimeout(() => this.setKoalaEmotion('normal'), 2000);
            }
        }

        triggerGameOver(reason) {
            Sound.bomb();
            this.setKoalaEmotion('panic');
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-score').innerText = `ÊúÄÁµÇÂàÜÊï∏: ${this.score}\n(${reason || 'Ê≤íÂú∞ÊñπÊîæ‰∫Ü'})`;
            document.getElementById('final-score').style.display = 'block';
        }

        updateScore(points) {
            this.score += points;
            document.getElementById('score').innerText = this.score;
            
            // ÂàÜÈñãÂÑ≤Â≠ò‰∏çÂêåÊ®°ÂºèÁöÑÊúÄÈ´òÂàÜ
            const key = `xr_puzzle_best_${this.mode}`;
            const currentBest = parseInt(localStorage.getItem(key) || 0);
            if(this.score > currentBest) {
                localStorage.setItem(key, this.score);
                document.getElementById('best-score').innerText = this.score;
            }
        }

        createParticles(gx, gy, color) {
            const cx = gx * this.cellSize + this.cellSize/2;
            const cy = gy * this.cellSize + this.cellSize/2;
            for(let i=0; i<5; i++) {
                this.particles.push({
                    x: cx, y: cy,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1, color: color, size: Math.random() * 10 + 5
                });
            }
        }

        updateParticles() {
            for(let i=this.particles.length-1; i>=0; i--) {
                let p = this.particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.05;
                if(p.life <= 0) {
                    this.particles.splice(i, 1);
                } else {
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                }
            }
        }

        showFloatText(text) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = text;
            el.style.left = '50%'; el.style.top = '40%';
            el.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        setKoalaEmotion(state) {
            const k = document.getElementById('koala-mascot');
            k.className = '';
            k.classList.add(`koala-${state}`);
        }
    }

    const game = new BlockPuzzle();
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>
